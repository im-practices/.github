# Workflow Code: GiddyBuzzard_v7    DO NOT REMOVE

# Note: The main purpose of this workflow is to verify that the database can be created, all of the migration scripts can be run, and any tests that exist pass.
#       In addition to that, however, there are three other things this workflow template is set up to do.
#         1. Create snapshots. Snapshots are create sql object (table, view, sproc, etc.) scripts that show the shape of an object and can be
#            useful for keeping a historical record in GitHub of the changes to them.
#         2. Create a backup of the database and store it for later consumption. The backup can then be used in a workflow to circumvent the need
#            to spin up the database from scratch. Very helpful for decreasing build times. Please note however that this is only a backup of a local database.
#            It does not take the place of backups that should be happening of Production databases.
#         3. Create mock sql objects that can be consumed by other database repos' CI processes. A flag on the build database step in this workflow can be set
#            so that your database's dependencies are downloaded and installed.
#
#       The need for creating snapshots and backups in this workflow is not a very common need. They are here in case you need them, but likely you won't.
#       There are TODO's throughout this template that let you know when something isn't necessary if you don't want snapshots and/or backups created.
#
#       Creating mock sql objects is a bit less rare of a need, but only if your database is a sectioned off part of the legacy ExtendHealth monolith. Again,
#       there will be TODO's showing you where some items can be removed if you don't have any dependencies and/or don't need to create mock objects to be
#       consumed by others.

name: Build Database CI
# TODO: Select the appropriate trigger, if push and pull are both included, two builds will be kicked off when a PR exists and a new commit is pushed to the corresponding branch.
on:
  # This workflow will run for the PR events:
  # opened/reopened: A PR is opened/re-opened,
  # synchronize: The PR's head branch is updated (commits pushed, the base branch changed or the head is updated from the base branch)
  # closed: A PR is merged or closed (The triggers job makes sure we only run if a merge happened, not when a close happens)
  pull_request:
    types: [opened, reopened, synchronize, closed]
env:
  DB_NAME: '' # TODO: Fill in your repo's database name
  DB_SERVER_NAME: 'localhost'
  DB_SERVER_PORT: '1433'
  DEFAULT_BRANCH: 'main' # TODO: verify default branch name
  ARTIFACTORY_URL: 'https://artifacts.mktp.io/artifactory/api/nuget/nuget-all' # TODO: This is used when grabbing dependency scripts and when publishing dependency scripts for others to use. Remove if that isn't something your repo needs to do.
  ARTIFACTORY_RETRIEVAL_URL: 'https://artifacts.mktp.io/artifactory/api/nuget/nuget-all' # TODO: This can be removed if your database doesn't have any dependency objects stored in artifactory
  FLYWAY_MANAGED_SCHEMAS: 'dbo' # TODO: update this comma separated value with all of the schemas that Flyway manages. E.g. dbo,MyCustomSchema,AnotherSchema
  SQL_LOGIN_USERNAME: 'SA' # The default SA account SQL Server comes with

  # TODO: The following are all for the snapshot step below and can be removed if it's not used
  SNAPSHOT_PATH: './snapshot' # TODO: Verify this path is correct
  EXCLUDED_DB_SNAPSHOT_OBJECTS: '' # TODO: Add some comma separated values to this

  # TODO: These next variables are for backing up the database. Remove if not needed.
  BACKUP_PATH: '' # TODO: The path on the action runner to put the backup path
  BACKUP_FILENAME: '' # TODO: The name to give the backup file

jobs:
  # TODO: If you don't need to create snapshots, backups, or mock objects then this whole job can be removed. Make sure to update the 'needs' of later jobs accordingly.
  set-vars:
    runs-on: ubuntu-latest
    outputs:
      last-commit-is-snapshot: ${{ steps.capture-branch-state.outputs.isSnapshot }} # TODO: Can be useful for if logic to skip steps. Remove if this isn't something you need to branch on.
      current-branch-is-default: ${{ steps.capture-branch-state.outpus.isDefaultBranch }} # TODO: Can be useful for if logic to skip steps. Remove if your CI process is the same for all branches.
      should-skip-remaining-workflow-jobs: ${{ steps.capture-branch-state.outputs.skip }} # TODO: This is only needed if your workflow is committing a snapshot and needs to skip running the CI for that commit. Remove this and its usages if not needed.
      artifactory-publish-url: ${{ steps.set-artifactory-url.outputs.url }} # TODO: Remove this if you don't need to create mock objects for other repos to consume.
    steps:
      - uses: actions/checkout@v2

      # TODO: Remove this if you don't need to create mock objects for other repos to consume.
      # The outputted url will point to nuget-branch or nuget-master, depending on the current branch
      - name: Set artifactory publish url
        id: set-artifactory-url
        shell: pwsh
        run: |
          $CurrentBranch = git rev-parse --abbrev-ref HEAD
          $CurrentBranchIsDefault = ($CurrentBranch -eq "${{ env.DEFAULT_BRANCH }}")
          $ArtifactoryUrl = "https://artifacts.mktp.io/artifactory/api/nuget"

          if ($CurrentBranchIsDefault)
          {
            $ArtifactoryUrl = $ArtifactoryUrl + "/nuget-master/Database"
          }
          else
          {
            $ArtifactoryUrl = $ArtifactoryUrl + "/nuget-branches/Database"
          }

          echo "::set-output name=url::$ArtifactoryUrl"

      # TODO: Update or remove this if you aren't creating snapshots and/or are doing the same CI process for every branch.
      - name: Capture branch details
        id: capture-branch-state
        shell: pwsh
        run: |
          $CurrentBranch = git rev-parse --abbrev-ref HEAD
          $LastCommitBy = git --no-pager show -s --format="%aN"
          $CurrentBranchIsDefault = ($CurrentBranch -eq "${{ env.DEFAULT_BRANCH }}")
          $LastCommitIsSnapshot = ($LastCommitBy -eq "github-actions")

          echo "::set-output name=isDefaultBranch::$CurrentBranchIsDefault"
          echo "::set-output name=isSnapshot::$LastCommitIsSnapshot"

          if ($LastCommitIsSnapshot -and !$CurrentBranchIsDefault)
          {
            Write-Host "Snapshot was last commit, skipping the other jobs"
            echo "::set-output name=skip::true"
          }
          else
          {
            Write-Host "Snapshot was not the last commit, continuing with the other jobs"
            echo "::set-output name=skip::false"
          }

  # TODO: Remove this linting job if your project doesn't need/want it
  lint-migration-files:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    needs: set-vars # TODO: Remove this if you deleted the set-vars job
    if: ${{ needs.set-vars.outputs.should-skip-remaining-workflow-jobs == 'false' }} # TODO: Remove this if there is no snapshot commit that should cause this step to be skipped.
    steps:
      - uses: actions/checkout@v2

      - uses: actions/setup-node@v2
        with:
          node-version: '14' # TODO: The current LTS version. Can be updated to something else if needed.

      - id: migration-folder
        shell: pwsh
        run: echo "::set-output name=folder::$($(Get-Date).Year).$($(Get-Date).Month.ToString("00"))"
      - name: SQL Lint
        uses: im-open/tsql-lint-action@v1.0.3
        with:
          tsqllint-version: 1.11.0
          path-to-sql-files: 'Database/src/SqlDatabase/Migrations/${{ steps.migration-folder.outputs.folder }}' # TODO: Update this path to wherever the files to lint live
          file-name-filter: 'V9*.sql' # TODO: Update this if necessary
          path-to-lint-config: ./.tsqllintrc # TODO: Update this with the path to your project's .tsllintrc file

  build-database:
    runs-on: [self-hosted, ubuntu-20.04]
    needs: [set-vars, lint-migration-files] # TODO: Remove any jobs you deleted above
    if: ${{ needs.set-vars.outputs.should-skip-remaining-workflow-jobs == 'false' }} # TODO: Remove this if there is no snapshot commit that should cause this step to be skipped.
    steps:
      - uses: actions/checkout@v2

      - name: Install Flyway
        uses: im-open/setup-flyway@v1.0.2
        with:
          version: 7.2.0 # This version works with the current version of build-database-ci-action. Newer versions might, but they should be tested.

      # TODO: This can be removed if your database doesn't have database object dependencies that it needs to download and install in order to build and run tests.
      - name: Install and run dependency scripts
        uses: im-open/install-and-run-db-dependency-scripts@v1.1.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          username: '${{ env.SQL_LOGIN_USERNAME }}'
          password: ${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }} # This is an org-level secret
          # TODO: Fill in this list with real values.
          dependency-list: >-
            [
            {
            'version': '1.0.0',
            'packageName': 'Some_Dependency',
            'nugetUrl': '${{ env.ARTIFACTORY_URL }}/Path/To/Some_Dependency.1.0.0.nupkg'
            },
            {
            'version': '1.0.0',
            'packageName': 'Some_Other_Dependency',
            'nugetUrl': '${{ env.ARTIFACTORY_URL }}/Path/To/Some_Other_Dependency.1.0.0.nupkg'
            }
            ]

      - name: Run Migration Scripts
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '${{ env.MIGRATIONS_PATH }}'
          flyway-command: 'migrate'
          migration-history-table: 'MigrationHistory' # TODO: Update this if your flyway migration history table is something different
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # Run the migration scripts containing the tSQLt tests
      - name: Set up the tests
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '' # TODO: Add the path to your testing migration scripts here
          flyway-command: 'migrate'
          migration-history-table: 'TestingHistory'
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # TODO: The following schema binding steps are necessary for some teams' tests.
      #       Remove the steps if your tests do not require schema binding to be off.
      # NOTE: The following step uses the DBA.usp_ToggleSchemaBindingBatch stored procedure.
      #       If your project doesn't have this sproc, remove the three schema binding steps.
      - name: Output toggle schema binding queries for test objects
        id: schema-binding-queries
        shell: pwsh
        run: |
          $fakeTablePattern = "tSQLt.FakeTable\s+(@TableName\s*=\s*)?N?'([^']+)'"
          $objectNames = (
            Get-ChildItem ./src/TempTests/*.sql -File -Recurse |
            Where-Object { $_.Name.StartsWith("R__") } |
            ForEach-Object {
              Get-Content -Raw $_.FullName |
              Select-String -Pattern $fakeTablePattern -AllMatches |
              ForEach-Object { $_.Matches } |
              ForEach-Object { $_.Groups[2].Value }
            } |
            Sort-Object |
            Get-Unique
          )
          $objectNames = $objectNames -join ','
          Write-Output $objectNames

          if (-Not [string]::IsNullOrEmpty($objectNames))
          {
            $setStatements = "
              SET NOEXEC OFF;
              SET ANSI_NULL_DFLT_ON ON;
              SET ANSI_NULLS ON;
              SET ANSI_PADDING ON;
              SET ANSI_WARNINGS ON;
              SET ARITHABORT ON;
              SET CONCAT_NULL_YIELDS_NULL ON;
              SET QUOTED_IDENTIFIER ON;
              SET XACT_ABORT ON;"

            $getToggleQuery = "
              $setStatements
              DECLARE @unbindSql VARCHAR(MAX);
              DECLARE @rebindSql VARCHAR(MAX);

              BEGIN TRY
                EXEC DBA.usp_ToggleSchemaBindingBatch @objectList = N'$objectNames', @mode = 'VARIABLE', @isSchemaBoundOnly = 1, @unbindSql = @unbindSql OUTPUT, @rebindSql = @rebindSql OUTPUT;
                SELECT @unbindSql as unbindSql, @rebindSql as rebindSql;
              END TRY
              BEGIN CATCH
                THROW;
              END CATCH;"

            $toggleQueryTimeout = 120

            Write-Output "Getting schemabinding toggle queries"
            $toggleschemabinding = Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$getToggleQuery" -QueryTimeout $toggleQueryTimeout -MaxCharLength 150000
            Write-Output "Setting removeSchemaBindingSql"
            $removeSchemaBindingSql = "
              $setStatements
              BEGIN TRY
                BEGIN TRANSACTION;
                " + $toggleschemabinding.unbindSql + "
                COMMIT TRANSACTION;
              END TRY
              BEGIN CATCH
                IF (@@TRANCOUNT > 0)
                BEGIN
                  ROLLBACK TRANSACTION;
                END;
                
                THROW;
                RETURN;
              END CATCH;"
            
            Write-Output "Setting restoreSchemaBindingSql"
            $restoreSchemaBindingSql = "
              $setStatements
              BEGIN TRY
                BEGIN TRANSACTION;
                " + $toggleschemabinding.rebindSql + "
                COMMIT TRANSACTION;
              END TRY
              BEGIN CATCH
                IF (@@TRANCOUNT > 0)
                BEGIN
                  ROLLBACK TRANSACTION;
                END;

                THROW;
                RETURN;
              END CATCH;"

            # Substitute newline characters so we can output them
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("%", "%25")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("`n", "%0A")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("`r", "%0D")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace('"', '`"')

            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("%", "%25")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("`n", "%0A")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("`r", "%0D")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace('"', '`"')

            echo "::set-output name=remove_schema_binding_query::$removeSchemaBindingSql"
            echo "::set-output name=restore_schema_binding_query::$restoreSchemaBindingSql"
          }

      # TODO: Remove this if you don't need to toggle schema binding for tests
      - name: Toggle off schema binding for objects that need it
        shell: pwsh
        run: |
          $removeSchemaBindingSql = "${{ steps.schema-binding-queries.outputs.remove_schema_binding_query }}"
          if (-Not [string]::IsNullOrEmpty($removeSchemaBindingSql))
          { 
            Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$removeSchemaBindingSql" -QueryTimeout 120
          }

      - name: Run tSqlt tests
        id: run-tests
        uses: im-open/tsqlt-test-runner@initial-implementation # v1.0.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          query-timeout: '120' # 2 minutes
          use-integrated-security: 'false'
          db-username: '${{ env.SQL_LOGIN_USERNAME }}'
          db-password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # TODO: Remove this if you don't need to toggle schema binding for tests
      - name: Toggle schema binding back on
        shell: pwsh
        run: |
          $restoreSchemaBindingSql = "${{ steps.schema-binding-queries.outputs.restore_schema_binding_query }}"
          if (-Not [string]::IsNullOrEmpty($restoreSchemaBindingSql))
          { 
            Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$restoreSchemaBindingSql" -QueryTimeout 120
          }

      # Load seed data for integration tests
      # TODO: Remove this if you don't have integration tests or don't have seed data they rely on
      - name: Load seed data into the database
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '' # TODO: Add the path to your seed data migration scripts
          flyway-command: 'migrate'
          migration-history-table: 'SeedDataHistory'
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret


      #########################################################################################################################
      # The previous three steps are all that most builds will need. They will build your database on the Action Runner and run any tests you have.
      # The following steps are for the three activities mentioned at the start of this template.
      #   1. Creating snapshots
      #   2. Creating mock sql objects
      #   3. Creating a backup
      # Remove the ones that are unnecessary for your repo's CI process.
      #########################################################################################################################

      # The next four steps can be removed if your build doesn't need to create snapshots of database objects.
      # Otherwise they can be uncommented and the TODO's addressed.
      # TODO: Replace what is in this step with what your build needs in order to determine what database objects have changed
      # The output is a json string containing a list of objects with the following properties (see https://github.com/im-open/increment-database-object-snapshots#inputs for more information)
      #   * objectName
      #   * schemaName
      #   * objectType
      #   * operationType
      # - name: Get db objects that have changed
      #   id: changed-objects
      #   shell: pwsh
      #   run: |
      #     $changedObjectsQuery =
      #       "SELECT
      #           objectId,
      #           schemaName,
      #           objectName,
      #           CASE objectType
      #             WHEN 'U' THEN 'Tables'
      #             WHEN 'V' THEN 'Views'
      #             WHEN 'P' THEN 'StoredProcedures'
      #             WHEN 'SO' THEN 'Sequences'
      #             WHEN 'TF' THEN 'UserDefinedFunctions'
      #             WHEN 'FN' THEN 'UserDefinedFunctions'
      #             WHEN 'IF' THEN 'UserDefinedFunctions'
      #             WHEN 'SN' THEN 'Synonyms'
      #             ELSE objectType
      #           END AS objectType,
      #           operationType
      #         FROM DBA.V_ChangedObjectsForSnapshot"

      #     $changedObjects = Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }}" -Database "${{ env.DB_NAME }}" -Query $changedObjectsQuery
      #     $mappedObjects = $changedObjects | foreach-object { @{ schemaName=$_.schemaName; objectName=$_.objectName; objectType=$_.objectType; operationType=$_.operationType } }
      #     $objectsAsJson = $mappedObjects | ConvertTo-Json -Compress

      #     echo "::set-output name=json::$objectsAsJson"

      # - name: Increment snapshots
      #   uses: im-open/increment-database-object-snapshots@v1.0.2
      #   with:
      #     db-name: ${{ env.DB_NAME }}
      #     instance-name: ${{ env.DB_SERVER_NAME }}
      #     snapshot-path: ${{ env.SNAPSHOT_PATH }}
      #     objects-to-increment: '${{ steps.changed-objects.outputs.json }}'
      #     excluded-db-objects: ${{ env.EXCLUDED_DB_SNAPSHOT_OBJECTS }}

      # - name: Setup git for snapshot commit
      #   run: |
      #     git config user.name github-actions
      #     git config user.email github-actions@github.com

      # TODO: Update the commit message if desired
      # - name: Commit the snapshots
      #   run: |
      #     git add ${{ env.SNAPSHOT_PATH }}
      #     git commit -m "Automated Snapshot Commit"
      #     git push -f origin HEAD

      ##### End of snapshot steps #####

      # Remove this if you don't need to publish mock sql objects
      # - name: Create and publish views from tables
      #   uses: im-open/sql-view-to-table-generator@v1.0.3
      #   with:
      #     schema-names: 'dbo,CustomSchema' # TODO: Replace this with an actual list
      #     db-name: ${{ env.DB_NAME }}
      #     db-server: ${{ env.DB_SERVER_NAME }}
      #     default-branch: ${{ env.DEFAULT_BRANCH }}
      #     nuget-retrieval-url: ${{ env.ARTIFACTORY_URL }}
      #     publish-packages: true
      #     nuget-publish-url: ${{ needs.set-vars.outputs.artifactory-publish-url }}
      #     nuget-api-key: '${{ secrets.ARTIFACTORY_USERNAME }}:${{ secrets.ARTIFACTORY_API_KEY }}'

      # TODO: This is needed only if you have to update what objects have changed so it can be used in another step like changed-objects.
      #       Remove or update as needed.
      # - name: Update database object versions
      #   shell: pwsh
      #   run: |
      #     $updateObjectVersionsSQL = "EXEC DBA.usp_UpdateCheckSumForChangedObjectDefinitions;"
      #     Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }}" -Database "${{ env.DB_NAME }}" $updateObjectVersionsSQL

      # TODO: Remove this if your build doesn't need to create/publish backup files
      # - name: Create and publish backup files
      #   uses: im-open/create-and-publish-db-backup-file@v1.0.2
      #   with:
      #     db-server: ${{ env.DB_SERVER_NAME }}
      #     db-name: ${{ env.DB_NAME }}
      #     backup-path: '${{ env.BACKUP_PATH }}' # This can be changed if needed
      #     backup-name: '${{ env.BACKUP_FILENAME }}'
      #     version: '1.1.${{ github.run_number }}' # TODO: Set to 1.1.*** in order to not conflict with previous versions from Teamcity. Update this if desired.
      #     nuget-source-url: '${{ needs.set-vars.outputs.artifactory-publish-url }}'
      #     nuget-api-key: '${{ secrets.ARTIFACTORY_USERNAME }}:${{ secrets.ARTIFACTORY_API_KEY }}'
      #     authors: '' # TODO: This will get put in the .nuspec file. It should be updated with your team name or something similar.
