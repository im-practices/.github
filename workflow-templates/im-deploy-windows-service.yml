# Workflow Code: MaterialVolcano_v35    DO NOT REMOVE
# Purpose:
#    Gathers various stakeholder and attestor approvals, downloads artifacts from a release with the
#    specified tags, makes changes to any configuration files for the specified environments, stops
#    the service, deploys the pre-built artifacts to an on-prem machine then starts the service. Each
#    deployable project in a solution should have their own deployment workflow.
#
# Frequency:
#    Each deployable on-prem service in the repository should have their own copy of this workflow rather than trying to deploy several
#    on-prem service with the same workflow.  If the service is deployed as part of a group, the service still needs its own copy of this
#    workflow but it will be streamlined (instructions below) since the Deploy Multiple Items workflow handles many of these checks.
#
# Projects to use this Template with:
#    - Windows Service (Core Template)
#
# TODO: Prerequisites:
#     - Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.
#     - Set up a deployment board if it does not already exist: https://github.com/im-practices/git-er-done/blob/main/actions/deployment-board.md
#       Generally one board should be set up per windows service in the repository.
#     - The target server must be domain joined. If this is not the case already, create an ITHD ticket to have it joined to
#       the ExtendHealth domain for service account authentication
#     - Create an ITHD ticket to have an ExtendHealth Active directory service account created for each deployment environment.
#       That service account should then be added to an AD Group Policy Object (GPO); that GPO will then be applied to target
#       servers/deployment environments. If this deployment process and the service accounts are no longer needed at some point, let
#       let infrastructure know that they can remove the accounts and GPOs
#     - Make sure the Service account secrets have been added to the environment
#     - Do not use the instructions in the windows server action to prep the target server for WinRM connections,
#       those instructions are more for an open-source user. Instead, WinRM listeners should already be configured on target servers.
#       If a WinRM connection can't be established create an ITHD ticket to have the WinRM listeners fixed or created

name: Deploy Windows Service # TODO: If there are multiple on prem services in the repo, append the service name to this workflow's file name and update this name
run-name: Deploy ${{ inputs.tag }} to ${{ inputs.environment }} Windows Service
on:
  # TODO: If the repository has a single deployable artifact or multiple deployables that are deployed independently:
  #       1. Use the workflow_dispatch trigger
  #       2. Delete the repository_dispatch trigger and comments below.
  workflow_dispatch:
    inputs:
      tag:
        description: The tag for the release that will be deployed.  For Production, only tags reachable by the default branch will be accepted.
        required: true
      environment:
        description: The environment to deploy to.
        required: true
        type: choice
        options: # TODO:  Update for your available environments
          - dev
          - qa
          - stage
          - demo
          - uat
          - prod

  # TODO: If a repository has multiple deployable artifacts that are deployed together through the 'Deploy Multiple Items' workflow:
  #       1. Uncomment the repository_dispatch trigger
  #       2. Delete the workflow_dispatch trigger
  #       3. Change the env.ENVIRONMENT value from "${{ inputs.environment }}" to: "${{ github.event.client_payload.environment }}"
  #       4. Change the env.RELEASE_TAG value from "${{ inputs.tag }}" to: "${{ github.event.client_payload.tag }}"
  #       5. Under the 'set-vars' job:
  #          a. Delete the 'Checkout Repository' step
  #          b. Delete the 'Verify Tag Exists' step
  #       6. Delete the 'stakeholder-approval' job
  #       7. Delete the 'attestor-approval' job
  #       8. Delete the 'validate-tag-is-in-main-for-prod-deploys' job
  #       9. Under the 'deploy-service-to-machine' job, update the needs property to be: "needs: [set-vars]"
  # repository_dispatch:
  #   types: [<deployable_name>_deploy] # TODO: Replace <deployable_name>.  This will be used in the 'Deploy Multiple Items' workflow to target this deployment workflow.

env:
  ENVIRONMENT: ${{ inputs.environment }}
  RELEASE_TAG: ${{ inputs.tag }}
  # TODO: Add any global environment vars that don't change based on deployment environment (dev, qa, stage....)

jobs:
  # This job utilizes a reusable workflow which will:
  #   1 - Verify the tag provided is a valid ref.
  #   2 - If deploying to a production environment, verify the tag is reachable from the default branch 
  #       and that the corresponding release is production ready (not pre-release or a draft).
  setup-deployment-workflow:
    uses: im-practices/.github/.github/workflows/im-reusable-setup-deployment-workflow.yml@v2
    with:
      ref-to-deploy: ${{ inputs.tag }}
      deployment-environment: ${{ inputs.environment }}
      # production-environments: 'prod,prod-secondary'  # TODO:  Adjust and include the production-environments if necessary (some apps may need to add stage/stage-secondary to this list)
      # default-branch: main # TODO:  Update and include this arg if the default branch is not main
      # workflow-summary : | # TODO:  If desired, the workflow summary that is generated can be overridden by providing this custom value.

  set-vars:
    needs: [setup-deployment-workflow]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    environment: ${{ inputs.environment }} # Use inputs context because env context is not available to environment:

    outputs:
      WINDOWS_SERVERS: ${{ steps.set-variables.outputs.WINDOWS_SERVERS }}
      SERVICE_NAME: ${{ steps.set-variables.outputs.SERVICE_NAME }}
      SERVICE_PATH: ${{ steps.set-variables.outputs.SERVICE_PATH }}
      RUN_TIME_ID: ${{ steps.set-variables.outputs.RUN_TIME_ID }}
      DEPLOYMENT_SA_ID: ${{ steps.set-variables.outputs.DEPLOYMENT_SA_ID }}

    steps:
      # For more information and best practices on the usage and options available
      # for this action go to: https://github.com/im-open/set-environment-variables-by-scope#usage-instructions
      - name: Set Variables
        id: set-variables
        uses: im-open/set-environment-variables-by-scope@v1.1
        with:
          scope: ${{ env.ENVIRONMENT }}
          create-output-variables: true
        env:
          # Each server should be a FQDN name (target-server.extendhealth.com) for the DNS request
          # Format for WINDOWS_SERVERS: "['env-machine-name-1.extendhealth.com', 'env-machine-name-2.extendhealth.com']"
          # TODO:  Fill in the list of machines for each environment.  Remove environments that are not applicable.
          WINDOWS_SERVERS@dev: "['', '']"
          WINDOWS_SERVERS@qa: "['', '']"
          WINDOWS_SERVERS@stage: "['', '']"
          WINDOWS_SERVERS@demo: "['', '']"
          WINDOWS_SERVERS@uat: "['', '']"
          WINDOWS_SERVERS@prod: "['', '']"
          # TODO: Fill in the SERVICE_NAME and remove the environments that are not used.
          SERVICE_NAME@dev: ''
          SERVICE_NAME@qa: ''
          SERVICE_NAME@stage: ''
          SERVICE_NAME@demo: ''
          SERVICE_NAME@uat: ''
          SERVICE_NAME@prod: ''
          # TODO: Fill in the SERVICE_PATH (location where the service is deployed) and remove the environments that are not used.
          SERVICE_PATH@dev: ''
          SERVICE_PATH@qa: ''
          SERVICE_PATH@stage: ''
          SERVICE_PATH@demo: ''
          SERVICE_PATH@uat: ''
          SERVICE_PATH@prod: ''
          # TODO: Fill in the RUN_TIME_ID and remove the environments that are not used.
          # These are the service accounts that the service will run under.
          RUN_TIME_ID@dev: ''
          RUN_TIME_ID@qa: ''
          RUN_TIME_ID@stage: ''
          RUN_TIME_ID@demo: ''
          RUN_TIME_ID@uat: ''
          RUN_TIME_ID@prod: ''
          # TODO: Fill in the deployment service account id and remove the environments that are not used.
          # These are the service accounts that have permission to remotely connect to the machine an execute commands.
          DEPLOYMENT_SA_ID@dev: ''
          DEPLOYMENT_SA_ID@qa: ''
          DEPLOYMENT_SA_ID@stage: ''
          DEPLOYMENT_SA_ID@prod: ''

  # Each env has their own stakeholder approval environment.  If no required reviewers are set for
  # that environment, the workflow will continue without requiring anyone to approve the deployment.
  stakeholder-approval:
    needs: [set-vars]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    environment: '${{ inputs.environment }} Stakeholder Approval' # Use inputs context because env context is not available to environment:
    steps:
      - name: Approval Received
        run: |
          echo "The current environment is ${{ env.ENVIRONMENT }}.  The Tag is ${{ env.RELEASE_TAG }}."
          echo "Stakeholder approval was received or no required reviewers were set for this environment."

  # Each env has their own attestor approval environment (meant for QA Attestations).  If no required reviewers are set for
  # that environment, the workflow will continue without requiring anyone to approve the deployment.
  attestor-approval:
    needs: [set-vars]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    environment: '${{ inputs.environment }} Attestor Approval' # Use inputs context because env context is not available to environment:
    steps:
      - run: |
          echo "The current environment is ${{ env.ENVIRONMENT }}.  The Tag is ${{ env.RELEASE_TAG }}."
          echo "Attestor approval was received or no required reviewers were set for this environment."

  # If you want to verify that the Jira ticket being deployed has the proper attestations, there is an action for that.
  # https://github.com/im-open/verify-fields-on-jira-task
  # Set up a new job, or add to an existing one that makes sense, and add a step with that action.
  # Details on how to use the action can be found in the action's README.

  deploy-service-to-machine:
    needs: |
      - set-vars
      - stakeholder-approval
      - attestor-approval
    runs-on: [self-hosted, windows-2019] # In order to use WinRM this must remain as a windows runner
    environment: ${{ inputs.environment }} # Use inputs context because env context is not available to environment:

    strategy:
      fail-fast: false # Don't cancel all deploy jobs if one of the deployments fails
      max-parallel: 1 # Only deploy to one machine at a time, to minimize downtime
      matrix:
        # This should be an array of windows machine names.
        # One job will spawn for each server listed in the array
        windows-server: ${{ fromJSON(needs.set-vars.outputs.WINDOWS_SERVERS) }}

    defaults:
      run:
        shell: pwsh

    env:
      PAGERDUTY_WINDOW_IN_MIN: 30 # TODO: Verify the length of your PD Maintenance Window
      PAGERDUTY_WINDOW_DESC: 'Deploying Code to ${{ inputs.environment }} from GitHub Actions' # TODO: Verify this PD Maintenance Window Description
      ASSET_ZIP: 'published_app.zip' # TODO: Verify that this wasn't changed in the CI build.  This is the value in that workflow by default.
      UNZIPPED_ASSET: 'published_app'
      DEPLOY_ZIP: 'deploy.zip'
      # The username/secret of the admin account that can deploy to the machine
      DEPLOYMENT_SA_ID: ${{ needs.set-vars.outputs.DEPLOYMENT_SA_ID }}
      DEPLOYMENT_SA_SECRET: ${{ secrets.DEPLOYMENT_SA_SECRET }}
      # The username/secret that the windows service runs under
      RUN_TIME_ID: ${{ needs.set-vars.outputs.RUN_TIME_ID }}
      RUN_TIME_SECRET: ${{ secrets.RUN_TIME_SECRET }}
      SERVICE_NAME: ${{ needs.set-vars.outputs.SERVICE_NAME }}
      SERVICE_PATH: ${{ needs.set-vars.outputs.SERVICE_PATH }}

    steps:
      - run: echo "The current environment is ${{ env.ENVIRONMENT }}.  The Tag is ${{ env.RELEASE_TAG }}.  The current machine is ${{ matrix.windows-server }}"

      - name: Open a PagerDuty Maintenance Window
        id: open-window
        uses: im-open/open-pagerduty-maintenance-window@v1.2
        with:
          pagerduty-api-key: ${{ secrets.PAGERDUTY_API_KEY }} # This is an env-level secret
          description: '${{ env.PAGERDUTY_WINDOW_DESC }}'
          minutes: ${{ env.PAGERDUTY_WINDOW_IN_MIN }}
          service-id: ${{ vars.PAGERDUTY_SERVICE_ID }} # This is an env-level variable
          #service-ids: '' # TODO: Provide a comma separated list if there are multiple ids. 'PD01,PD02,PD03'

      # For more information and best practices on the usage and options available
      # for this action go to: https://github.com/im-open/set-environment-variables-by-scope#usage-instructions
      - name: Set Variables
        id: set-variables
        uses: im-open/set-environment-variables-by-scope@v1.1
        with:
          scope: ${{ env.ENVIRONMENT }}
          create-output-variables: true
        env:
          # TODO: Add the values your app/function needs to be configured with (appsettings.json/local.settings.json/octo var substitution/config changes).  Delete envs that are not used.
          #  - The name of the env (left side of @) (ex: FedAuth_Domain) should be added.  The env name can be used in the later variable-substitution and octostache actions for replacement.
          #  - The scope (right side of @) should be dev/qa/stage/uat/demo/prod. This action uses the value of env.ENVIRONMENT to match one of the scopes (envs) below.  Multiple items can be added as well (ex: @stage demo)
          #  - The value for the environment should be included in '' after the colon. (ex: 'fedauth.dev.viabenefits.com')
          # FedAuth_Domain@dev: 'fedauth.dev.viabenefits.com'
          # FedAuth_Domain@qa: 'fedauth.qa.viabenefits.com'
          # FedAuth_Domain@stage demo: 'fedauth.stage.viabenefits.com'
          # FedAuth_Domain@prod: 'fedauth.viabenefits.com'

      - name: Download artifacts from release
        uses: im-open/download-release-asset@v1.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          asset-name: ${{ env.ASSET_ZIP }}
          tag-name: ${{ inputs.tag }}

      - name: Unzip release asset
        run: Expand-Archive -LiteralPath ${{ env.ASSET_ZIP }} -DestinationPath ./${{ env.UNZIPPED_ASSET }}

      # TODO: If you need to do any Octopus variable substitution (i.e. replacing #{OCTO_PLACEHOLDER} in files) use the following action.  Delete if not using.
      # This action works well with the im-open/set-environment-variables-by-scope action. Environment variables set in that action will be utilized by this one.
      # https://github.com/im-open/octostache-action
      - uses: im-open/octostache-action@v4.0
        with:
          variables-file: '' # TODO: Add the ./path/file containing the variable substitutions to make, you will need to create this file  See the action for more details.
          files-with-substitutions: '' # TODO: Add the paths to the files to make substitutions in, e.g. .${{ env.UNZIPPED_ASSET }}/**/*.config
        # env: # TODO: Environment variables can be added that will also be used for substitution (good for secrets). These will override any variable in the variables-file with the same name.

      # TODO: If you need any json, yml or xml file (web.config/app.config/nlog.config) substitutions use the following
      #        action, otherwise delete it. This action won't add or remove items, it will just update the values.
      - uses: im-open/variable-substitution@v2
        with:
          files: '' # TODO: add a comma separated list of files and the patterns, like '${{ env.UNZIPPED_ASSET }}/*.config', ./src/MyProj/We*.config, ./src/MyProj/Nlog.config'
        env:
          # TODO: replace examples with actual substitutions
          # FedAuth.Domain: ${{ env.FedAuth_Domain }} # Example showing replacement at a nested node (left side) & using the env set in the set-environment-variables-by-scope step above (right side)
          # SecretValue: ${{ secrets.VALUE }} # Example showing replacement of a root level value (left side) with a secret (right side)

      - name: Zip the published app for faster deployment and uploads
        run: |
          # On a Windows build runner, the 'zip' commandline tool isn't available. Use PowerShell functions instead.
          Compress-Archive -Path .\${{ env.UNZIPPED_ASSET }}\* -DestinationPath ${{ env.DEPLOY_ZIP }}

      - name: Stop Service
        id: stop-service
        if: always()
        uses: im-open/windows-service-action@v2.0
        with:
          action: 'stop'
          server: ${{ matrix.windows-server }}
          service-name: ${{ env.SERVICE_NAME }}
          service-account-id: ${{ env.DEPLOYMENT_SA_ID }}
          service-account-password: ${{ env.DEPLOYMENT_SA_SECRET }}
        continue-on-error: true

      - name: Deploy Deployment Package
        id: deploy
        if: steps.app-pool-stop.outcome == 'success'
        uses: im-open/deploy-windows-files@v2.0
        with:
          server: ${{ matrix.windows-server }}
          service-account-id: ${{ env.DEPLOYMENT_SA_ID }}
          service-account-password: ${{ env.DEPLOYMENT_SA_SECRET }}
          source-zip-file-path: ./${{ env.DEPLOY_ZIP }}
          deployment-folder-path: ${{ env.SERVICE_PATH }}
          clean-deployment-folder: 'true'

      - name: Register Service
        id: register
        if: steps.deploy.outcome == 'success'
        uses: im-open/register-windows-service@v3.0
        with:
          service-name: '${{ env.SERVICE_NAME }}'
          deployment-path: '${{ env.SERVICE_PATH }}\\win-service.exe' # TODO: Make sure the right service file name is
          server: ${{ matrix.windows-server }}
          # TODO: Verify the run time service account ids and secrets for all environments
          #       and put them in the GitHub Actions Environments Secrets store
          run-time-id: ${{ env.RUN_TIME_ID }} # TODO: If using the a local system account (NT AUTHORITY\LOCAL SYSTEM), remove this variable.
          run-time-secret: ${{ secrets.RUN_TIME_SECRET }} # TODO: If using the a local system account (NT AUTHORITY\LOCAL SYSTEM), remove this variable.
          deployment-id: ${{ env.DEPLOYMENT_SA_ID }}
          deployment-secret: ${{ secrets.DEPLOYMENT_SA_SECRET }}

      - name: Start Service
        if: steps.register.outcome == 'success'
        uses: im-open/windows-service-action@v2.0
        with:
          action: 'start'
          server: ${{ matrix.windows-server }}
          service-name: ${{ env.SERVICE_NAME }}
          service-account-id: ${{ env.DEPLOYMENT_SA_ID }}
          service-account-password: ${{ secrets.DEPLOYMENT_SA_SECRET }}

      - name: Close the PagerDuty Maintenance Window
        if: always() && steps.open-window.outcome == 'success'
        uses: im-open/close-pagerduty-maintenance-window@v1.1
        with:
          pagerduty-api-key: ${{ secrets.PAGERDUTY_API_KEY }} # This is an org-level secret
          maintenance-window-id: ${{ steps.open-window.outputs.maintenance-window-id }}

      - name: Delete .zips and folder that contains sensitive info
        continue-on-error: true
        working-directory: ${{ env.PROJECT_ROOT }}
        shell: bash
        run: |
          rm -f ${{ env.ASSET_ZIP }}
          rm -f ${{ env.DEPLOY_ZIP }}
          rm -rf ${{ env.UNZIPPED_ASSET }}
  
  # This job utilizes a reusable workflow which will:
  #  1 - Update the deployment board based on the workflow conclusion
  #  2 - Post a deployment status in the repo owner's Teams channel (connected to the MS_TEAMS_URI secret)
  #  3 - Post a deployment status in the Deployment Notifications Teams channel if the deploy is for prod, is successful and the flag to do so is not set to false
  update-deployment-board-and-send-teams-notification:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    needs: [set-vars, deploy-service-to-machine]
    if: always()
    uses: im-practices/.github/.github/workflows/im-reusable-finish-deployment-workflow.yml@v2
    with:
      # Required Inputs
      deployment-environment: ${{ inputs.environment }} # The environment/target that was deployed to (dev, qa, stage, stage-secondary, uat, demo, prod, prod-secondary)
      gh-secrets-environment: ${{ inputs.environment }} # The GitHub environment that secrets are pulled from
      release-tag: ${{ inputs.tag }}
      title-of-teams-post: 'Deploy ${{ needs.set-vars.outputs.SERVICE_NAME }} ${{ inputs.tag }} to ${{ inputs.environment }}' # TODO:  Verify title to ensure it is descriptive/readable.
      
      # Optional Inputs with their default values.  These items can be removed if the default value does not need to be adjusted.
      # post-status-in-deployment-notifications-channel: true # TODO:  Include this arg and set to false if you do not want a status post in the Deployment Notifications channel for prod deploys
      # timezone: 'america/denver'                            # TODO:  Include this argument and update if your timezone is not america/denver
      # deployment-board-number: 1                            # TODO:  Include this argument and update if your deployment board is not 1
      # deployable-type: ''                                   # TODO:  If there are multiple deployables in the repository, add a string type like MFE/DB/API for the deployment board
      # TODO:  These are the custom facts that will be included the different Teams posts by default.  If adjusting the facts that are supplied, they must be a valid JSON array.
      # custom-facts-for-team-channel: |
      #   [
      #     { "name": "Workflow", "value": "${{ github.workflow }}" },
      #     { "name": "Run", "value": "${{ github.run_id }}" },
      #     { "name": "Actor", "value": "${{ github.actor }}" },
      #     { "name": "Version", "value": "${{ inputs.tag }}" }
      #   ]
      # custom-facts-for-deployment-notifications-channel: |
      #   [
      #     { "name": "Actor", "value": "${{ github.actor }}" },
      #     { "name": "Version", "value": "${{ inputs.tag }}" }
      #   ]
    secrets:
      MS_TEAMS_URI: ${{ vars.MS_TEAMS_URI }}
      DEPLOY_NOTIFICATIONS_CHANNEL: ${{ vars.DEPLOY_NOTIFICATIONS_CHANNEL }}    
