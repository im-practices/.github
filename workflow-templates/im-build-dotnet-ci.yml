# Workflow Code: LoathsomeSnipe_v22    DO NOT REMOVE

# TODO: Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.

# TODO: If the project contains a local nuget.config remove it.  It interferes with restoring packages on the GitHub Action runners.

name: .Net Core CI

on:
  # This workflow will run for the PR events:
  # opened/reopened: A PR is opened/re-opened,
  # synchronize: The PR's head branch is updated (commits pushed, the base branch changed or the head is updated from the base branch)
  # closed: A PR is merged or closed (The examine-triggers job makes sure we only run if a merge happened, not when a close happens)
  pull_request:
    types: [opened, reopened, synchronize, closed]

env:
  READ_PKG_TOKEN: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
  DOTNET_VERSION: '' # TODO: Add the .net version
  SOLUTION_FILE: '' # TODO: Fill in the path and name of the solution file
  REPO_URL: ${{ github.server_url }}/${{ github.repository }}
  TIMEZONE: America/Denver # TODO: Verify timezone

jobs:
  examine-triggers:
    runs-on: ubuntu-latest
    outputs:
      CONTINUE_WORKFLOW: ${{ env.CONTINUE_WORKFLOW }}
      IS_MERGE_TO_MAIN: ${{ env.IS_MERGE_TO_MAIN }}
      PRERELEASE: ${{ env.PRERELEASE }}

    steps:
      - run: |
          echo "CONTINUE_WORKFLOW=true" >> $GITHUB_ENV
          echo "IS_MERGE_TO_MAIN=false" >> $GITHUB_ENV
          echo "PRERELEASE=true" >> $GITHUB_ENV

      - if: github.event.action == 'closed' && github.event.pull_request.merged == false
        run: echo "CONTINUE_WORKFLOW=false" >> $GITHUB_ENV

      - if: github.event.action == 'closed' && github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main' # TODO: verify default branch name
        run: |
          echo "IS_MERGE_TO_MAIN=true" >> $GITHUB_ENV
          echo "PRERELEASE=false" >> $GITHUB_ENV

  dotnet-build-and-test:
    runs-on: [self-hosted, ubuntu-20.04] # TODO: Switch this to [self-hosted, windows-2019] if building a db

    needs: [examine-triggers]
    if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      coverage: ${{ steps.dotnet_coverage_check.outputs.coverage-outcome }}
      test: ${{ steps.dotnet_test_check.outputs.test-outcome }}

    env:
      CODE_COVERAGE_REPORT_NAME_DOTNET: '<project-name> .Net Code Coverage' # TODO: Replace <project-name>
      CODE_COVERAGE_CHECK_NAME_DOTNET: 'dotnet code coverage'
      CODE_COVERAGE_DIR_DOTNET: 'coverage-results/dotnet'

      # TODO: Remove the following vars if not setting up a db during ci
      FLYWAY_VERSION: '' # TODO: Add the flyway version
      DB_NAME: '' # TODO: The name of the database
      INSTALL_MOCK_DB_OBJ: '' # TODO: [true|false] Indicates whether you want mock objects installed on the db.  Delete if not using.
      MOCK_DB_OBJ_URL: '' # TODO: The url to the nuget feed that contains your mock db obs.  Delete if not using mock db objects.
      DROP_DB_AFTER_STEP: '' # TODO: [true|false] Indicates whether the db should be dropped after the build step

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      # TODO: Delete the install flyway and build database steps if not building a database
      - name: Install Flyway
        uses: im-open/setup-flyway@v1.0.2
        with:
          version: ${{ env.FLYWAY_VERSION }}

      # TODO: If you are using any nuget/npm packages from GitHub Packages uncomment this step
      # - name: Authenticate with GitHub Packages
      #   uses: im-open/authenticate-with-gh-package-registries@v1.0.5
      #   with:
      #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
      #     orgs: 'im-client,im-enrollment,im-practices' # TODO: Verify list of orgs packages will be pulled from

      # TODO: This can be removed if your database doesn't have database object dependencies that it needs to download and install in order to build and run tests.
      - name: Install and run dependency scripts
        uses: im-open/install-and-run-db-dependency-scripts@v1.1.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          username: '${{ env.SQL_LOGIN_USERNAME }}'
          password: ${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }} # This is an org-level secret
          # TODO: Fill in this list with real values.
          dependency-list: >-
            [
            {
            'version': '1.0.0',
            'packageName': 'Some_Dependency',
            'nugetUrl': '${{ env.ARTIFACTORY_URL }}/Path/To/Some_Dependency.1.0.0.nupkg'
            },
            {
            'version': '1.0.0',
            'packageName': 'Some_Other_Dependency',
            'nugetUrl': '${{ env.ARTIFACTORY_URL }}/Path/To/Some_Other_Dependency.1.0.0.nupkg'
            }
            ]

      - name: Run Migration Scripts
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '${{ env.MIGRATIONS_PATH }}'
          flyway-command: 'migrate'
          migration-history-table: 'MigrationHistory' # TODO: Update this if your flyway migration history table is something different
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # Run the migration scripts containing the tSQLt tests
      - name: Set up the tests
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '' # TODO: Add the path to your testing migration scripts here
          flyway-command: 'migrate'
          migration-history-table: 'TestingHistory'
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # TODO: The following schema binding steps are necessary for some teams' tests.
      #       Remove the steps if your tests do not require schema binding to be off.
      # NOTE: The following step uses the DBA.usp_ToggleSchemaBindingBatch stored procedure.
      #       If your project doesn't have this sproc, remove the three schema binding steps.
      - name: Output toggle schema binding queries for test objects
        id: schema-binding-queries
        shell: pwsh
        run: |
          $fakeTablePattern = "tSQLt.FakeTable\s+(@TableName\s*=\s*)?N?'([^']+)'"
          $objectNames = (
            Get-ChildItem ./src/TempTests/*.sql -File -Recurse |
            Where-Object { $_.Name.StartsWith("R__") } |
            ForEach-Object {
              Get-Content -Raw $_.FullName |
              Select-String -Pattern $fakeTablePattern -AllMatches |
              ForEach-Object { $_.Matches } |
              ForEach-Object { $_.Groups[2].Value }
            } |
            Sort-Object |
            Get-Unique
          )
          $objectNames = $objectNames -join ','
          Write-Output $objectNames

          if (-Not [string]::IsNullOrEmpty($objectNames))
          {
            $setStatements = "
              SET NOEXEC OFF;
              SET ANSI_NULL_DFLT_ON ON;
              SET ANSI_NULLS ON;
              SET ANSI_PADDING ON;
              SET ANSI_WARNINGS ON;
              SET ARITHABORT ON;
              SET CONCAT_NULL_YIELDS_NULL ON;
              SET QUOTED_IDENTIFIER ON;
              SET XACT_ABORT ON;"

            $getToggleQuery = "
              $setStatements
              DECLARE @unbindSql VARCHAR(MAX);
              DECLARE @rebindSql VARCHAR(MAX);

              BEGIN TRY
                EXEC DBA.usp_ToggleSchemaBindingBatch @objectList = N'$objectNames', @mode = 'VARIABLE', @isSchemaBoundOnly = 1, @unbindSql = @unbindSql OUTPUT, @rebindSql = @rebindSql OUTPUT;
                SELECT @unbindSql as unbindSql, @rebindSql as rebindSql;
              END TRY
              BEGIN CATCH
                THROW;
              END CATCH;"

            $toggleQueryTimeout = 120

            Write-Output "Getting schemabinding toggle queries"
            $toggleschemabinding = Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$getToggleQuery" -QueryTimeout $toggleQueryTimeout -MaxCharLength 150000
            Write-Output "Setting removeSchemaBindingSql"
            $removeSchemaBindingSql = "
              $setStatements
              BEGIN TRY
                BEGIN TRANSACTION;
                " + $toggleschemabinding.unbindSql + "
                COMMIT TRANSACTION;
              END TRY
              BEGIN CATCH
                IF (@@TRANCOUNT > 0)
                BEGIN
                  ROLLBACK TRANSACTION;
                END;
                
                THROW;
                RETURN;
              END CATCH;"
            
            Write-Output "Setting restoreSchemaBindingSql"
            $restoreSchemaBindingSql = "
              $setStatements
              BEGIN TRY
                BEGIN TRANSACTION;
                " + $toggleschemabinding.rebindSql + "
                COMMIT TRANSACTION;
              END TRY
              BEGIN CATCH
                IF (@@TRANCOUNT > 0)
                BEGIN
                  ROLLBACK TRANSACTION;
                END;

                THROW;
                RETURN;
              END CATCH;"

            # Substitute newline characters so we can output them
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("%", "%25")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("`n", "%0A")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace("`r", "%0D")
            $removeSchemaBindingSql = $removeSchemaBindingSql.Replace('"', '`"')

            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("%", "%25")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("`n", "%0A")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace("`r", "%0D")
            $restoreSchemaBindingSql = $restoreSchemaBindingSql.Replace('"', '`"')

            echo "::set-output name=remove_schema_binding_query::$removeSchemaBindingSql"
            echo "::set-output name=restore_schema_binding_query::$restoreSchemaBindingSql"
          }

      # TODO: Remove this if you don't need to toggle schema binding for tests
      - name: Toggle off schema binding for objects that need it
        shell: pwsh
        run: |
          $removeSchemaBindingSql = "${{ steps.schema-binding-queries.outputs.remove_schema_binding_query }}"
          if (-Not [string]::IsNullOrEmpty($removeSchemaBindingSql))
          { 
            Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$removeSchemaBindingSql" -QueryTimeout 120
          }

      - name: Run tSqlt tests
        id: run-tests
        uses: im-open/tsqlt-test-runner@initial-implementation # v1.0.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          query-timeout: '120' # 2 minutes
          use-integrated-security: 'false'
          db-username: '${{ env.SQL_LOGIN_USERNAME }}'
          db-password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      # TODO: Remove this if you don't need to toggle schema binding for tests
      - name: Toggle schema binding back on
        shell: pwsh
        run: |
          $restoreSchemaBindingSql = "${{ steps.schema-binding-queries.outputs.restore_schema_binding_query }}"
          if (-Not [string]::IsNullOrEmpty($restoreSchemaBindingSql))
          { 
            Invoke-Sqlcmd -ServerInstance "${{ env.DB_SERVER_NAME }},${{ env.DB_SERVER_PORT }}" -Database "${{ env.DB_NAME }}" -Query "$restoreSchemaBindingSql" -QueryTimeout 120
          }

      # Load seed data for integration tests
      # TODO: Remove this if you don't have integration tests or don't have seed data they rely on
      - name: Load seed data into the database
        uses: im-open/run-flyway-command@v1.3.0
        with:
          db-server-name: '${{ env.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ env.DB_NAME }}'
          migration-files-path: '' # TODO: Add the path to your seed data migration scripts
          flyway-command: 'migrate'
          migration-history-table: 'SeedDataHistory'
          managed-schemas: '${{ env.FLYWAY_MANAGED_SCHEMAS }}'
          validate-migrations: 'true'
          use-integrated-security: 'false' # Integrated Security only works on Windows runners
          username: '${{ env.SQL_LOGIN_USERNAME }}' # If using integrated security the only place this is used is in the migration history table
          password: '${{ secrets.ACTIONS_RUNNER_MSSQL_SA_PWD }}' # This is an org-level secret

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: dotnet build
        run: dotnet build ${{ env.SOLUTION_FILE }} --configuration Release

      # TODO: The TEST projects need a package reference to coverlet.msbuild for this to output the coverage reports correctly:
      #        <PackageReference Include="coverlet.msbuild" Version="3.1.0" />
      # TODO: Filters can be added to exclude certain tests: https://docs.microsoft.com/en-us/dotnet/core/testing/selective-unit-tests?pivots=xunit
      - name: dotnet test with coverage
        continue-on-error: true
        run: dotnet test ${{ env.SOLUTION_FILE }} --logger trx --no-build --configuration Release /property:CollectCoverage=True /property:CoverletOutputFormat=opencover

      - name: create status check/comment for test results
        id: dotnet_test_check
        uses: im-open/process-dotnet-test-results@v2.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          timezone: ${{ env.TIMEZONE }}
          # TODO: Determine if you would like status checks, pr comments or both
          create-status-check: true
          create-pr-comment: true
          # update-comment-if-one-exists: false # TODO: By default this action creates one comment and updates it for each subsequent workflow run.  Uncomment if you wish to have one new comment for every workflow run.

      - name: create code coverage report
        uses: im-open/code-coverage-report-generator@4.8.14
        with:
          reports: '*/**/coverage.opencover.xml'
          targetdir: ${{ env.CODE_COVERAGE_DIR_DOTNET }}
          title: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          tag: 'Workflow: ${{ github.workflow }} <br/> Run Number: ${{ github.run_number }} <br/> Run ID: ${{ github.run_id }}'
          # TODO: Add the appropriate filters to each type.
          # The filters are a ; separated list of items to include(+) or exclude(-).  Wildcards are accepted.
          # For instance: -xunit*;-Dapper;-*.Tests
          assemblyfilters: ''
          filefilters: ''
          classfilters: ''

      - name: create status check/comment for code coverage results
        id: dotnet_coverage_check
        uses: im-open/process-code-coverage-summary@v2.1.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          summary-file: '${{ env.CODE_COVERAGE_DIR_DOTNET }}/Summary.md'
          report-name: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          check-name: ${{ env.CODE_COVERAGE_CHECK_NAME_DOTNET }}
          # TODO: Determine if you would like status checks, pr comments or both
          create-status-check: true
          create-pr-comment: true
          # update-comment-if-one-exists: false # TODO: By default this action creates one comment and updates it for each subsequent workflow run.  Uncomment if you wish to have one new comment for every workflow run.
          update-comment-key: dotnet
          # TODO: Set the thresholds for branch and line coverage.
          # When set to 0 the outcome is neutral.  Otherwise line/branch coverage will be a 'failure' if actual coverage < threshold.
          line-threshold: 0
          branch-threshold: 0

      - name: upload dotnet code coverage report
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.CODE_COVERAGE_REPORT_NAME_DOTNET }}
          path: ${{ env.CODE_COVERAGE_DIR_DOTNET }}

  # TODO: Remove this job if you do not have jest tests
  jest:
    runs-on: [self-hosted, ubuntu-20.04]

    needs: [examine-triggers]
    if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      coverage: ${{ steps.jest_coverage_check.outputs.coverage-outcome }}
      test: ${{ steps.jest_test_check.outputs.test-outcome }}

    env:
      CODE_COVERAGE_REPORT_NAME_JEST: '<project-name> Jest Code Coverage' # TODO: Replace <project-name>
      CODE_COVERAGE_CHECK_NAME_JEST: 'jest code coverage'
      CODE_COVERAGE_DIR_JEST: 'coverage-results/jest'
      JEST_TEST_DIR: '' # TODO: Add the path to dir containing the package.json file that knows how to run the jest tests.  Like ./src/MyApp.Bff/FrontEnd
      JEST_TEST_RESULTS_FILE: 'jest-results.json'
      JEST_TEST_REPORT_NAME: 'Jest Tests'

    steps:
      - uses: actions/checkout@v2

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # TODO: If you are using any nuget/npm packages from GitHub Packages uncomment this step
      # - name: Authenticate with GitHub Packages
      #   uses: im-open/authenticate-with-gh-package-registries@v1.0.5
      #   with:
      #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
      #     orgs: 'im-client,im-enrollment,im-practices' # TODO: Verify list of orgs packages will be pulled from

      - name: restore npm packages
        working-directory: ${{ env.JEST_TEST_DIR }}
        run: npm ci

      - name: jest test with coverage
        continue-on-error: true
        working-directory: ${{ env.JEST_TEST_DIR }}
        # TODO: If your script in package.json for running jest is named something besides 'test' update it here
        # TODO: If your script in package.json does not include the --coverage or --json flags, add them to the script in package.json
        run: npm run test -- --outputFile=${{ env.JEST_TEST_RESULTS_FILE }}

      - name: create status check/comment for jest test results
        id: jest_test_check
        uses: im-open/process-jest-test-results@v2.0.3
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          timezone: ${{ env.TIMEZONE }}
          results-file: ${{ env.JEST_TEST_DIR }}/${{ env.JEST_TEST_RESULTS_FILE }}
          report-name: ${{ env.JEST_TEST_REPORT_NAME }}
          # TODO: Determine if you would like status checks, pr comments or both
          create-status-check: true
          create-pr-comment: true
          # update-comment-if-one-exists: false # TODO: By default this action creates one comment and updates it for each subsequent workflow run.  Uncomment if you wish to have one new comment for every workflow run.

      - name: create code coverage report
        uses: im-open/code-coverage-report-generator@4.8.14
        with:
          reports: '*/**/lcov.info'
          targetdir: ${{ env.CODE_COVERAGE_DIR_JEST }}
          title: jest code coverage
          tag: 'Workflow: ${{ github.workflow }} <br/> Run Number: ${{ github.run_number }} <br/> Run ID: ${{ github.run_id }}'
          # TODO: Add the appropriate filters to each type.
          # The filters are a ; separated list of items to include(+) or exclude(-).  Wildcards are accepted.
          # For instance: -xunit*;-Dapper;-*.Tests
          assemblyfilters: ''
          filefilters: ''
          classfilters: ''

      - name: create status check/comment for code coverage results
        id: jest_coverage_check
        uses: im-open/process-code-coverage-summary@v2.1.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          summary-file: '${{ env.CODE_COVERAGE_DIR_JEST }}/Summary.md'
          report-name: ${{ env.CODE_COVERAGE_REPORT_NAME_JEST }}
          check-name: ${{ env.CODE_COVERAGE_CHECK_NAME_JEST }}
          # TODO: Determine if you would like status checks, pr comments or both
          create-status-check: true
          create-pr-comment: true
          # update-comment-if-one-exists: false # TODO: By default this creates one comment and updates it for each run.  Uncomment if you wish to have one new comment for every workflow run.
          update-comment-key: jest
          # TODO: Set the thresholds for branch and line coverage.
          # When set to 0 the outcome is neutral.  Otherwise line/branch coverage will be a 'failure' if actual coverage < threshold.
          line-threshold: 0
          branch-threshold: 0

      - name: upload jest code coverage report
        uses: actions/upload-artifact@v2
        with:
          name: ${{ env.CODE_COVERAGE_REPORT_NAME_JEST }}
          path: ${{ env.CODE_COVERAGE_DIR_JEST }}

  validate-sam-yaml:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners

    needs: [examine-triggers]
    if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    outputs:
      validate: ${{ steps.sam-yaml.outputs.validation-outcome }}

    steps:
      - uses: actions/checkout@v2

      - name: Validate SAM.yaml
        continue-on-error: true
        id: sam-yaml
        uses: im-open/yaml-file-validation@v1.0.5
        with:
          yaml-file-path: ./SAM.yml # TODO: Verify name, case and extension of your sam.yml file
          schema-file-path: 'SAM'

  build-deployment-artifacts:
    runs-on: ubuntu-latest
    needs: [examine-triggers, dotnet-build-and-test, jest, validate-sam-yaml] # TODO: Update if any jobs were added/removed/renamed (usually jest has been removed)
    if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    defaults:
      run:
        shell: bash

    outputs:
      NEXT_VERSION: ${{ steps.version.outputs.NEXT_VERSION }}

    env:
      IS_MERGE_TO_MAIN: ${{ needs.examine-triggers.outputs.IS_MERGE_TO_MAIN }}
      PRERELEASE: ${{ needs.examine-triggers.outputs.PRERELEASE }}

      # TODO: If you have a single deployable in the repo, use these variables and delete the multi-deployable block below
      PROJECT_ROOT: '' # TODO: Fill in the path to the folder containing the project that will be deployed, like ./src/MyBff
      PUBLISHED_APP: 'published_app' # Value will be used in the deployment workflow
      DEPLOY_ZIP: 'published_app.zip' # Value will be used in the deployment workflow

      # TODO: For multiple deployables, each deployable should have a block with the appropriate values and delete the single-deployable block above.
      # PROJECT_ROOT_SITE: '' # TODO: Fill in the path to the folder containing the project that will be deployed, like ./src/MyBff
      # PUBLISHED_SITE: 'published_site' # Value will be used in the deployment workflow
      # DEPLOY_ZIP_SITE: 'published_site.zip' # Value will be used in the deployment workflow
      # PROJECT_ROOT_API: '' # TODO: Fill in the path to the folder containing the project that will be deployed, like ./src/MyBff
      # PUBLISHED_API: 'published_api' # Value will be used in the deployment workflow
      # DEPLOY_ZIP_API: 'published_api.zip' # Value will be used in the deployment workflow

    steps:
      # We don't want to create a release if there were test/build failures, so check the conclusion
      - name: Check workflow status to this point
        uses: im-open/workflow-conclusion@v2.0.0
        id: conclusion
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          # TODO: Determine if there are any additional step outcomes/outputs you want considered or steps that need to be removed
          additional-conclusions: |
            [
              { "name": "dotnet test", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.test }}" },
              { "name": "dotnet coverage", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.coverage }}" },
              { "name": "jest test", "conclusion" : "${{ needs.jest.outputs.test }}" },
              { "name": "jest coverage", "conclusion" : "${{ needs.jest.outputs.coverage }}" },
              { "name": "sam.yaml validation", "conclusion" : "${{ needs.validate-sam-yaml.outputs.validate }}" }
            ]

      - name: Do not create a release if there have been failures
        if: steps.conclusion.outputs.workflow_conclusion != 'success'
        run: |
          echo "The workflow was not successful up to this point.  A release will not be created.  Check the 'Check workflow status to this point' step above for more details on what failed."
          exit 1

      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Setup .NET Core
        uses: actions/setup-dotnet@v1
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      # TODO: If you are using any nuget/npm packages from GitHub Packages uncomment this step
      # - name: Authenticate with GitHub Packages
      #   uses: im-open/authenticate-with-gh-package-registries@v1.0.5
      #   with:
      #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
      #     orgs: 'im-client,im-enrollment,im-practices' # TODO: Verify list of orgs packages will be pulled from

      # TODO: If you have multiple deployables in the repo and each deployable has it's own tag:
      #       1 - Duplicate this step once per deployable
      #       2 - Duplicate the following Build and Publish step, changing it to build one deployable at a time instead of the whole solution.
      #       3 - Update the ID so the NEXT_VERSION can be referenced elsewhere
      #       4 - Uncomment and add a value for the prefix (mfe/db/site/api/etc) so the deployable's tag can be incremented.
      #       5 - At the top of this job, add a NEXT_VERSION with the appropriate prefix/suffix for the deployable
      - name: Calculate next version
        id: version
        uses: im-open/git-version-lite@v2.0.6
        with:
          calculate-prerelease-version: ${{ env.PRERELEASE }}
          branch-name: ${{ github.head_ref }} # This is only populated when the trigger is pull_request, otherwise it is empty
          # tag-prefix: '' # TODO: If you prefix your tags like (mfe/db/etc) uncomment and add that value here

      # TODO: If there are multiple deployables, duplicate this step once per deployable project and update the PROJECT_ROOT, PUBLISHED_APP and DEPLOY_ZIP variables with the updated names.
      - name: Build and Publish
        working-directory: ${{ env.PROJECT_ROOT }}
        shell: pwsh # On a Windows build runner, the 'zip' commandline tool isn't available. Use PowerShell instead.
        run: |
          $VERSION_ONLY = ($env:NEXT_VERSION).substring(1)  # Removes the leading 'v'. TODO: Use a different expression to strip a tag-prefix if you've specified one.
          dotnet build --configuration Release /p:Version=$VERSION_ONLY
          dotnet publish --configuration Release --no-build -o ./${{ env.PUBLISHED_APP }}
          Compress-Archive -Path ./${{ env.PUBLISHED_APP }}/* -DestinationPath ${{ env.DEPLOY_ZIP }}

      # TODO: If you have multiple deployables and there are different tags for each deployable:
      #        1 - Duplicate the 'Create Release with published_artifacts' step, once per deployable
      #        2 - Remove the ID
      #        3 - Update the step where tag-name gets its value from.  steps.version should be updated to the new deployable-specific id set above
      #        4 - Update the PROJECT_ROOT and DEPLOY_ZIP variables to use the deployable-specific value

      # WARNING!!! This will upload the published artifacts to the release.  If you have done any transformations
      # on the config files and included sensitive information (that isn't already present in committed files)
      # that sensitive info will be available to download by anyone with read access to this repo.
      - name: Create Release with published_artifacts
        id: create_release
        uses: im-open/create-release@v2.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          delete-existing-release: true # Handy when you hit 're-run jobs' on a workflow run
          tag-name: ${{ steps.version.outputs.NEXT_VERSION }}
          prerelease: ${{ env.PRERELEASE }}
          # TODO: if there are multiple deployables that use the same tag (and release), delete these three items.
          #        If there is only a single deployable, or multiple deployables that have different tags keep these items.
          asset-path: ${{ env.PROJECT_ROOT }}/${{ env.DEPLOY_ZIP }}
          asset-name: ${{ env.DEPLOY_ZIP }}
          asset-content-type: application/zip

      # TODO: If you have multiple deployables that use the same tag (and release), duplicate this action once per deployable.  It will upload
      #        each release asset individually.  Ensure the variables (PROJECT_ROOT, DEPLOY_ZIP) are updated with the appropriate PROJECT_ROOT and DEPLOY_ZIP
      #        If there is only a single deployable, or multiple deployables that have different tags delete this step.
      # - name: Upload Release Asset for <site/api/mfe/etc>
      #   uses: im-open/upload-release-asset@v1.0.1
      #   github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
      #   upload-url: ${{ steps.create_release.outputs.asset-upload-url }}
      #   asset-path: ${{ env.PROJECT_ROOT }}/${{ env.DEPLOY_ZIP }}
      #   asset-name: ${{ env.DEPLOY_ZIP }}
      #   asset-content-type: application/zip

      - name: Cleanup the branch pre-releases
        if: env.IS_MERGE_TO_MAIN == 'true'
        uses: im-open/delete-prereleases-for-branch@v1.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          branch-name: ${{ github.head_ref }}

  finish-build:
    if: always() && needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'
    needs: # TODO: Update the needs [] list if any jobs were added/removed/renamed
      [
        dotnet-build-and-test,
        jest,
        validate-sam-yaml,
        build-deployment-artifacts,
      ]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    steps:
      - uses: im-open/workflow-conclusion@v2.0.0
        id: conclusion
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          # TODO: Determine if there are any additional step outcomes/outputs you want considered or remove some items if they do not apply (like jest)
          additional-conclusions: |
            [
              { "name": "dotnet test", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.test }}" },
              { "name": "dotnet coverage", "conclusion" : "${{ needs.dotnet-build-and-test.outputs.coverage }}" },
              { "name": "jest test", "conclusion" : "${{ needs.jest.outputs.test }}" },
              { "name": "jest coverage", "conclusion" : "${{ needs.jest.outputs.coverage }}" },
              { "name": "sam.yaml validation", "conclusion" : "${{ needs.validate-sam-yaml.outputs.validate }}" }
            ]

      - name: Send Status to Teams
        if: always()
        continue-on-error: true
        uses: im-open/post-status-to-teams-action@v1.0.2
        with:
          title: '<project-name> CI Build' # TODO: Replace <project-name>
          workflow-status: ${{ steps.conclusion.outputs.workflow_conclusion }}
          workflow-type: Build
          teams-uri: ${{ secrets.MS_TEAMS_URI }} # This is a repo-level secret (unless 'environment:' has been added to the finish-build job)
          timezone: ${{ env.TIMEZONE }}
          custom-facts: |
            [
              { "name": "Workflow", "value": "${{ github.workflow }}" },
              { "name": "Run", "value": "${{ github.run_id }}" },
              { "name": "Actor", "value": "${{ github.actor }}" },
              { "name": "Version", "value": "${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}" }
            ]

      - name: Comment on PR with version ${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}
        if: github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          script: |
            let nextVersion = '${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}';
            let hasRelease = nextVersion && nextVersion.length > 0;
            let releaseText = hasRelease ?
              '[Release - ${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}](${{ env.REPO_URL }}/releases/${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }})' :
              'Release - N/A';
            const commentBody = `
            - [Workflow Run - ${{ steps.conclusion.outputs.workflow_conclusion }}](${{ env.REPO_URL }}/actions/runs/${{ github.run_id }})
            - ${releaseText}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

      - name: Check for Failures
        if: steps.conclusion.outputs.workflow_conclusion == 'failure'
        run: |
          echo "There were errors in the workflow.  Check the workflow-conclusion step above for more details on what failed."
          exit 1
      # NOTE:  Currently this is not working and WTW needs needs to whitelist our actions runners in order to initiate a scan
      # TODO: Delete if you have other triggers for checkmarx scans
      # TODO: Uncomment once this workflow has been merged to master at least once.  The repository_dispatch event won't work until the checkmarx workflow is in main.
      # - name: Kick off Checkmarx if workflow succeeded
      #   if: steps.conclusion.outputs.workflow_conclusion == 'success'
      #   uses: actions/github-script@v5
      #   with:
      #     github-token: ${{ secrets.PIPELINE_BOT_PAT }} # This is an org-level secret
      #     script: |
      #       github.rest.repos.createDispatchEvent({
      #         owner: context.repo.owner,
      #         repo: context.repo.repo,
      #         event_type: 'run_checkmarx',
      #         client_payload: {
      #           ref: "${{ needs.build-deployment-artifacts.outputs.NEXT_VERSION }}"
      #         }
      #       });
