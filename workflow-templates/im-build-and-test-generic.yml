# Workflow Code: MadLark_v1    DO NOT REMOVE
# Purpose:
#    Provide a framework for building and testing multiple project types in 
#    this repository in parallel jobs in response to pull requests.
#    Each build-test job should check out the code, build one project, run its
#    associated tests and upload the packaged binaries as an artifact.
#    After all the build-test jobs have completed, the create-release job
#    will upload the built artifacts to a GitHub release asset.
#
# Frequency:
#    - This workflow should only be used once per repository
#
# Projects to use this Template with:
#    - any repository with deployables
#    - monorepo style repositories
#
# TODO: Prerequisites:
#    - Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.

name: üè≠ CI Build

on:
  # This workflow will run for the PR events:
  # opened/reopened: A PR is opened/re-opened,
  # synchronize: The PR's head branch is updated (commits pushed, the base branch changed or the head is updated from the base branch)
  # closed: A PR is merged or closed (The examine-triggers job makes sure we don't build anything if a PR is closed without being merged)
  pull_request:
    types: [opened, reopened, synchronize, closed]

env:
  READ_PKG_TOKEN: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
  REPO_URL: ${{ github.server_url }}/${{ github.repository }}
  MS_TEAMS_CONNECTOR: '' # TODO: supply the Teams webhook URL
  TIMEZONE: America/Denver # TODO: Verify timezone

jobs:
  examine-triggers:
    runs-on: ubuntu-latest
    outputs:
      CONTINUE_WORKFLOW: ${{ env.CONTINUE_WORKFLOW }}
      CREATE_RELEASE: ${{ env.CREATE_RELEASE }}
      IS_PRERELEASE: ${{ env.IS_PRERELEASE }}
      NEXT_VERSION: ${{ env.NEXT_VERSION }}
      REF_TO_BUILD_AND_TAG: ${{ env.REF_TO_BUILD_AND_TAG }}

    steps:
      - name: Set default env variables
        uses: actions/github-script@v6
        with:
          script: |
            const targetRef = '${{ github.base_ref }}';
            const sourceRef = '${{ github.head_ref }}';
            const mergeRef = '${{ github.ref }}';

            const prIsDraft = '${{ github.event.pull_request.draft }}' === 'true';
            const prClosed = '${{ github.event.action }}' === 'closed';
            const prMerged = prClosed && '${{ github.event.pull_request.merged }}' === 'true';
            const prMergedToMain = prMerged && targetRef === 'main';
            const isPreRelease = !prMergedToMain;

            // For a detailed explanation of why we use different refs for different scenarios 
            // see https://docs.github.com/en/rest/reference/pulls#get-a-pull-request
            const refToBuildAndTag = prMergedToMain ? mergeRef : sourceRef;

            const continueWorkflow = prClosed && !prMerged ? false : true;
            const doTagRelease = continueWorkflow && !prIsDraft ? true :  false;

            core.exportVariable('IS_PRERELEASE', isPreRelease);
            core.exportVariable('REF_TO_BUILD_AND_TAG', refToBuildAndTag);
            core.exportVariable('CONTINUE_WORKFLOW', continueWorkflow);
            core.exportVariable('CREATE_RELEASE', doTagRelease);

      # NOTE: This workflow uses one version tag with no prefix for all the deployables in the repository.
      #       If you want each deployable to have it's own version tag prefix, this workflow is not for you.
      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          ref: ${{ env.REF_TO_BUILD_AND_TAG }}
      - name: Calculate next version
        id: version
        uses: im-open/git-version-lite@v2.0.8
        with:
          calculate-prerelease-version: ${{ env.IS_PRERELEASE }}
          branch-name: ${{ github.head_ref }} # This is only populated when the trigger is pull_request, otherwise it is empty

# start-project Inserts project build-and-test jobs here (don't delete this comment)
# For example
  # Mfe-build-and-test:
  #   runs-on: [self-hosted, ubuntu-20.04]
  #   needs: [examine-triggers]
  #   if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

  #   defaults:
  #     run:
  #       shell: bash
  #   env:
  #     MFE_PROJECT_ROOT: '/src/SomeDomain.Mfe' # TODO: specify the project directory
  #     MFE_TESTS_PROJECT_ROOT: '/tests/SomeDomain.Mfe.UnitTests' # TODO: specify the tests project directory
  #     CONTINUE_WORKFLOW: ${{ needs.examine-triggers.outputs.CONTINUE_WORKFLOW }}
  #     IS_PRERELEASE: ${{ needs.examine-triggers.outputs.IS_PRERELEASE }}
  #     NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}
  #     REF_TO_BUILD_AND_TAG: ${{ needs.examine-triggers.outputs.REF_TO_BUILD_AND_TAG }}

  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v2
  #       with:
  #         fetch-depth: 0
  #         ref: ${{ env.REF_TO_BUILD_AND_TAG }}

  #     # TODO: If you are using any nuget/npm packages from GitHub Packages uncomment this step
  #     # - name: Authenticate with GitHub Packages
  #     #   uses: im-open/authenticate-with-gh-package-registries@v1.0.5
  #     #   with:
  #     #     read-pkg-token: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
  #     #     orgs: 'im-client,im-enrollment,im-practices' # TODO: Verify list of orgs packages will be pulled from

  #     - name: Setup .NET Versions
  #       uses: actions/setup-dotnet@v1
  #       with:
  #         dotnet-version: | # TODO: verify the dotnet version(s) needed
  #           6.0

  #     - name: Setup node.js
  #       uses: actions/setup-node@v2
  #       with:
  #         node-version: '16'
  #         cache: 'npm'

  #     - name: dotnet build project
  #       id: build-project
  #       working-directory: ${{ env.MFE_PROJECT_ROOT }}
  #       run: |
  #         VERSION_ONLY=${NEXT_VERSION#?};  # Removes the first character (the 'v') from the NEXT_VERSION environment variable
  #         dotnet build --configuration Release /p:Version=$VERSION_ONLY

  #     - name: Create Web App project published artifacts
  #       id: publish-app
  #       working-directory: ${{ env.MFE_PROJECT_ROOT }}
  #       run: dotnet publish --no-build --configuration Release --output ./published_app

  #     - name: dotnet test with coverage
  #       id: test
  #       working-directory: ${{ env.MFE_TESTS_PROJECT_ROOT }}
  #       run: dotnet test --results-directory ../../coverage-results/dotnet --logger trx --configuration Release --collect:"XPlat Code Coverage" -- DataCollectionRunSettings.DataCollectors.DataCollector.Configuration.Format=opencover

  #     - name: create comment for test results
  #       if: always() && steps.test.outcome == 'success' || steps.test.outcome == 'failure'
  #       uses: im-open/process-dotnet-test-results@v2.1.0
  #       with:
  #         github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
  #         timezone: ${{ env.TIMEZONE }}
  #         create-status-check: false
  #         create-pr-comment: true
  #         comment-identifier: 'Mfe'
  #         # By default this action creates one comment and updates it for each subsequent workflow run.
  #         # update-comment-if-one-exists: false

  #     - name: create code coverage report
  #       id: code-coverage-report
  #       if: always() && steps.test.outcome == 'success' || steps.test.outcome == 'failure'
  #       uses: im-open/code-coverage-report-generator@4.8.14
  #       with:
  #         reports: '*/**/coverage.opencover.xml'
  #         targetdir: 'coverage-results/dotnet'
  #         title: '${{ env.MFE_PROJECT_ROOT }} dotnet Code Coverage'
  #         tag: 'Workflow: ${{ github.workflow }} <br/> Run Number: ${{ github.run_number }} <br/> Run ID: ${{ github.run_id }}'
  #         # TODO:  Add the appropriate filters of each type.
  #         # The filters are a ; separated list of items to include(+) or exclude(-).  Wildcards are accepted.
  #         # For instance: -xunit*;-Dapper;-*.Tests
  #         assemblyfilters: ''
  #         filefilters: ''
  #         classfilters: ''

  #     - name: upload dotnet code coverage report
  #       if: always() && steps.code-coverage-report.outcome == 'success'
  #       uses: actions/upload-artifact@v2
  #       with:
  #         name: '${{ env.MFE_PROJECT_ROOT }} dotnet Code Coverage'
  #         path: 'coverage-results/dotnet'

  #     - name: Zip the published app
  #       id: zip-app
  #       if: always() && steps.publish-app.outcome == 'success'
  #       shell: pwsh
  #       working-directory: ${{ env.MFE_PROJECT_ROOT }}
  #       run: Compress-Archive -Path published_app/* -DestinationPath SomeDomain.Mfe.zip

  #     - name: Upload published app zip to artifacts
  #       if: always() && steps.zip-app.outcome == 'success'
  #       uses: actions/upload-artifact@v2
  #       with:
  #         name: SomeDomain.Mfe
  #         path: '${{ env.BFF_PROJECT_ROOT }}/SomeDomain.Mfe.zip'

  create-release:
    runs-on: [self-hosted, ubuntu-20.04]

    needs:
      - examine-triggers
      # start-project Inserts project build-and-test job names here (don't delete this comment)
      # For example
      # - Mfe-build-and-test
    if: always() && needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    env:
      NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}
      IS_PRERELEASE: ${{ needs.examine-triggers.outputs.IS_PRERELEASE }}

    steps:
      - name: Create Empty Release
        id: create-empty-release
        uses: im-open/create-release@v2.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          tag-name: ${{ env.NEXT_VERSION }}
          prerelease: ${{ env.IS_PRERELEASE }}
          # TODO: add release notes

# start-project Inserts build artifact publishing steps here (don't delete this comment)
# For example
      # - name: Download published app zip artifact
      #   id: download-app
      #   continue-on-error: true
      #   if: needs.examine-triggers.outputs.HAS_BFF_CHANGES == 'true'
      #   uses: actions/download-artifact@v2
      #   with:
      #     name: SomeDomain.Mfe
      # - name: Add SomeDomain.Mfe to release
      #   if: always() && steps.download-app.outcome == 'success'
      #   uses: im-open/upload-release-asset@v1.0.1
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
      #     upload-url: ${{ steps.create-empty-release.outputs.asset-upload-url }}
      #     asset-path: SomeDomain.Mfe.zip
      #     asset-name: SomeDomain.Mfe.zip
      #     asset-content-type: application/zip

  finish-build:
    if: always() && needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'
    needs:
      - examine-triggers
      - create-release
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners

    env:
      NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}

    steps:
      - uses: im-open/workflow-conclusion@v2.0.0
        id: conclusion
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo

      - name: Send Status to Teams
        if: always()
        continue-on-error: true
        uses: im-open/post-status-to-teams-action@v1.0.0
        with:
          title: '${{ github.repository }} CI Build' # TODO: fill in a descriptive title
          workflow-status: ${{ steps.conclusion.outputs.workflow_conclusion }}
          workflow-type: Build
          teams-uri: ${{ env.MS_TEAMS_CONNECTOR }}
          timezone: ${{ env.TIMEZONE }}
          custom-facts: |
            [
              { "name": "Actor", "value": "${{ github.actor }}" },
              { "name": "Version", "value": "${{ env.NEXT_VERSION }}" }
            ]

      - name: Comment on PR with version ${{ env.NEXT_VERSION }}
        if: always() && github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          script: |
            let nextVersion = '${{ env.NEXT_VERSION }}';
            let hasRelease = nextVersion && nextVersion.length > 0;
            let releaseText = hasRelease ?
              '[Release - ${{ env.NEXT_VERSION }}](${{ env.REPO_URL }}/releases/${{ env.NEXT_VERSION }})' :
              'Release - N/A';
            const commentBody = `
            - [Workflow Run - ${{ steps.conclusion.outputs.workflow_conclusion }}](${{ env.REPO_URL }}/actions/runs/${{ github.run_id }})
            - ${releaseText}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

      - name: Kick off Checkmarx if workflow succeeded
        if: always() && steps.conclusion.outputs.workflow_conclusion == 'success'
        continue-on-error: true
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.PIPELINE_BOT_PAT }} # This is an org-level secret
          script: |
            github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'run_checkmarx',
              client_payload: {
                ref: "${{ env.NEXT_VERSION }}"
              }
            });

      - name: Fail if we should prevent the PR merge
        if: steps.conclusion.outputs.workflow_conclusion == 'failure'
        run: |
          echo "There were errors or failures in the workflow."
          exit 1
