# Workflow Code: MadLark_v1    DO NOT REMOVE
# Purpose:
#    Provide a framework for building and testing multiple project types in 
#    this repository in parallel jobs in response to pull requests.
#    Each build-test job should check out the code, build one project, run its
#    associated tests and upload the packaged binaries as an artifact.
#    After all the build-test jobs have completed, the create-release job
#    will upload the built artifacts to a GitHub release asset.
#
# NOTE:
#    This workflow uses one version tag with no prefix for all the deployables
#    in the repository. If you want each deployable to have it's own version
#    tag prefix, this workflow is not for you.
#
# Frequency:
#    - This workflow should only be used once per repository
#
# Projects to use this Template with:
#    - any repository with deployables
#    - monorepo style repositories
#
# TODO: Prerequisites:
#    - Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.

name: 🏭 CI Build

on:
  # This workflow only works with pull_request triggers.
  # It will run on these pull request events:
  # opened/reopened: A PR is opened/re-opened,
  # synchronize: The PR's head branch is updated (commits pushed, the base branch changed or the head is updated from the base branch)
  # closed: A PR is merged or closed (The examine-triggers job makes sure we don't build anything if a PR is closed without being merged)
  pull_request:
    types: [opened, reopened, synchronize, closed]

env:
  READ_PKG_TOKEN: ${{ secrets.READ_PKG_TOKEN }} # This is an org-level secret
  REPO_URL: ${{ github.server_url }}/${{ github.repository }}
  MS_TEAMS_CONNECTOR: '' # TODO: supply the Teams webhook URL
  TIMEZONE: America/Denver # TODO: Verify timezone

jobs:
  examine-triggers:
    runs-on: ubuntu-latest
    outputs:
      CONTINUE_WORKFLOW: ${{ env.CONTINUE_WORKFLOW }}
      CREATE_RELEASE: ${{ env.CREATE_RELEASE }}
      IS_PRERELEASE: ${{ env.IS_PRERELEASE }}
      NEXT_VERSION: ${{ env.NEXT_VERSION }}
      REF_TO_BUILD_AND_TAG: ${{ env.REF_TO_BUILD_AND_TAG }}

    steps:
      - name: Set default env variables
        uses: actions/github-script@v6
        with:
          script: |
            const targetRef = '${{ github.base_ref }}';
            const sourceRef = '${{ github.head_ref }}';
            const mergeRef = '${{ github.ref }}';

            const prIsDraft = '${{ github.event.pull_request.draft }}' === 'true';
            const prClosed = '${{ github.event.action }}' === 'closed';
            const prMerged = prClosed && '${{ github.event.pull_request.merged }}' === 'true';
            const prMergedToMain = prMerged && targetRef === 'main';
            const isPreRelease = !prMergedToMain;

            // For a detailed explanation of why we use different refs for different scenarios 
            // see https://docs.github.com/en/rest/reference/pulls#get-a-pull-request
            const refToBuildAndTag = prMergedToMain ? mergeRef : sourceRef;

            const continueWorkflow = prClosed && !prMerged ? false : true;
            const doTagRelease = continueWorkflow && !prIsDraft ? true :  false;

            core.exportVariable('IS_PRERELEASE', isPreRelease);
            core.exportVariable('REF_TO_BUILD_AND_TAG', refToBuildAndTag);
            core.exportVariable('CONTINUE_WORKFLOW', continueWorkflow);
            core.exportVariable('CREATE_RELEASE', doTagRelease);

      - name: Checkout Repository
        uses: actions/checkout@v2
        with:
          fetch-depth: 0
          ref: ${{ env.REF_TO_BUILD_AND_TAG }}
      - name: Calculate next version
        id: version
        uses: im-open/git-version-lite@v2.0.8
        with:
          calculate-prerelease-version: ${{ env.IS_PRERELEASE }}
          branch-name: ${{ github.head_ref }} # This is only populated when the trigger is pull_request, otherwise it is empty

# start-project Inserts project-specific build-and-test jobs here (don't delete this comment)
# For example
  # Mfe-build-and-test:
  #   runs-on: [self-hosted, ubuntu-20.04]
  #   needs: [examine-triggers]
  #   if: needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

  #   env:
  #     IS_PRERELEASE: ${{ needs.examine-triggers.outputs.IS_PRERELEASE }}
  #     NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}
  #     REF_TO_BUILD_AND_TAG: ${{ needs.examine-triggers.outputs.REF_TO_BUILD_AND_TAG }}

  #   steps:
  #     - name: Checkout Repository
  #       uses: actions/checkout@v2
  #       with:
  #         fetch-depth: 0
  #         ref: ${{ env.REF_TO_BUILD_AND_TAG }}
  #     - name: Build and Test
  #       uses: ./src/SomeDomain.Bff/build-and-test-action
  #       with:
  #         project_root: ./src/SomeDomain.Bff
  #         test_project_root: ./tests/SomeDomain.Mfe.UnitTests


  create-release:
    runs-on: [self-hosted, ubuntu-20.04]
    needs:
      - examine-triggers
      # start-project Inserts project build-and-test job names here (don't delete this comment)
      # For example
      # - Mfe-build-and-test
    if: always() && needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    env:
      NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}
      IS_PRERELEASE: ${{ needs.examine-triggers.outputs.IS_PRERELEASE }}

    steps:
      - name: Create Empty Release
        id: create-empty-release
        uses: im-open/create-release@v2.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          tag-name: ${{ env.NEXT_VERSION }}
          prerelease: ${{ env.IS_PRERELEASE }}
          # TODO: add release notes

# start-project Inserts build artifact publishing steps here (don't delete this comment)
# For example
      # - name: Download published app zip artifact
      #   id: download-app
      #   continue-on-error: true
      #   if: needs.examine-triggers.outputs.HAS_BFF_CHANGES == 'true'
      #   uses: actions/download-artifact@v2
      #   with:
      #     name: SomeDomain.Mfe
      # - name: Add SomeDomain.Mfe to release
      #   if: always() && steps.download-app.outcome == 'success'
      #   uses: im-open/upload-release-asset@v1.0.1
      #   with:
      #     github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
      #     upload-url: ${{ steps.create-empty-release.outputs.asset-upload-url }}
      #     asset-path: SomeDomain.Mfe.zip
      #     asset-name: SomeDomain.Mfe.zip
      #     asset-content-type: application/zip

  cleanup-prereleases-for-branch:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    needs: [examine-triggers, create-release]
    # Do this cleanup if create-release succeeds for a closed and merged PR or if the PR was closed without merging (CONTINUE_WORKFLOW == 'false').
    if: always() && ((needs.create-release.result == 'success' && github.event.pull_request.merged == 'true') || needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'false')

    steps:
      # Cleanup tags/releases for the closed PR's branch
      - name: Cleanup the branch pre-releases
        uses: im-open/delete-prereleases-for-branch@v1.0.2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          branch-name: ${{ github.head_ref }}

  finish-build:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    needs:
      - examine-triggers
      - create-release
    if: always() && needs.examine-triggers.outputs.CONTINUE_WORKFLOW == 'true'

    env:
      NEXT_VERSION: ${{ needs.examine-triggers.outputs.NEXT_VERSION }}

    steps:
      - uses: im-open/workflow-conclusion@v2.0.0
        id: conclusion
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo

      - name: Send Status to Teams
        if: always()
        continue-on-error: true
        uses: im-open/post-status-to-teams-action@v1.0.0
        with:
          title: '${{ github.repository }} CI Build' # TODO: fill in a descriptive title
          workflow-status: ${{ steps.conclusion.outputs.workflow_conclusion }}
          workflow-type: Build
          teams-uri: ${{ env.MS_TEAMS_CONNECTOR }}
          timezone: ${{ env.TIMEZONE }}
          custom-facts: |
            [
              { "name": "Actor", "value": "${{ github.actor }}" },
              { "name": "Version", "value": "${{ env.NEXT_VERSION }}" }
            ]

      - name: Comment on PR with version ${{ env.NEXT_VERSION }}
        if: always() && github.event_name == 'pull_request'
        continue-on-error: true
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} # Special per-job token generated by GH for interacting with the repo
          script: |
            let nextVersion = '${{ env.NEXT_VERSION }}';
            let hasRelease = nextVersion && nextVersion.length > 0;
            let releaseText = hasRelease ?
              '[Release - ${{ env.NEXT_VERSION }}](${{ env.REPO_URL }}/releases/${{ env.NEXT_VERSION }})' :
              'Release - N/A';
            const commentBody = `
            - [Workflow Run - ${{ steps.conclusion.outputs.workflow_conclusion }}](${{ env.REPO_URL }}/actions/runs/${{ github.run_id }})
            - ${releaseText}`;
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: commentBody
            });

      - name: Kick off Checkmarx if workflow succeeded
        if: always() && steps.conclusion.outputs.workflow_conclusion == 'success'
        continue-on-error: true
        uses: actions/github-script@v5
        with:
          github-token: ${{ secrets.PIPELINE_BOT_PAT }} # This is an org-level secret
          script: |
            github.rest.repos.createDispatchEvent({
              owner: context.repo.owner,
              repo: context.repo.repo,
              event_type: 'run_checkmarx',
              client_payload: {
                ref: "${{ env.NEXT_VERSION }}"
              }
            });

      - name: Fail if we should prevent the PR merge
        if: steps.conclusion.outputs.workflow_conclusion == 'failure'
        run: |
          echo "There were errors or failures in the workflow."
          exit 1
