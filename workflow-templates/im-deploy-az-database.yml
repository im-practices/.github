# Workflow Code: BetrayedCod_v24    DO NOT REMOVE
# Purpose:
#    Gathers the required approvals from stakeholders and attestors, ensures
#    tags are valid for production deployments and runs the migrations against
#    an Azure SQL database when someone kicks it off manually.
#
# Frequency:
#     Each deployable az db in the repository should have their own copy of this workflow rather than trying to deploy several
#     az databases with the same workflow.  If the db is deployed as part of a group, the db still needs its own copy of this
#     workflow but it will be streamlined (instructions below) since the Deploy Multiple Items workflow handles many of these checks.
#
# Projects to use this Template with:
#    - Azure SQL Database           (Core Template)
#
# TODO Prerequisites:
#    - Make sure the az secrets have been added to the environment
#    - Make sure the prod runners have access to the database with a 'azurerm_sql_virtual_network_rule'
#    - Ensure each of the repo-level and env-level secrets used in this workflow have been populated by an admin in your repository.
#    - Set up a deployment board if it does not already exist: https://github.com/im-practices/git-er-done/blob/main/actions/deployment-board.md
#      Generally one board should be set up per database in the repository.

name: Deploy Database to Azure # TODO: If there are multiple az databases in the repo, append the db name to this workflow's file name and update the workflow name below
run-name: Deploy ${{ inputs.tag }} to ${{ inputs.environment }} AZ DB
on:
  # TODO: If the repository has a single deployable artifact or multiple deployables that are deployed independently:
  #       1. Use the workflow_dispatch trigger
  #       2. Delete the repository_dispatch trigger and comments below.
  workflow_dispatch:
    inputs:
      tag:
        description: The tag for the release that will be deployed.  For Production, only tags reachable by the default branch will be accepted. Leave blank to use the workflow's branch.
        required: false
      environment-or-target:
        description: The environment or secondary region target to deploy to
        required: true
        type: choice
        options:
          - dev
          - qa
          - stage
          - demo
          - uat
          - prod
          - stage-secondary
          - prod-secondary

  # TODO: If a repository has multiple deployable artifacts that are deployed together through the 'Deploy Multiple Items' workflow:
  #       1. Uncomment the repository_dispatch trigger
  #       2. Delete the workflow_dispatch trigger
  #       3. Change the inputs.environment-or-target value from "${{ inputs.environment }}" to: "${{ github.event.client_payload.environment }}"
  #       4. Change the env.RELEASE_TAG value from "${{ inputs.tag }}" to: "${{ github.event.client_payload.tag }}"
  #       5. Delete the 'stakeholder-approval' job
  #       6. Delete the 'attestor-approval' job
  #       7. Delete the 'validate-tag-is-in-main-for-prod-deploys' job
  #       8. Under the 'deploy-az-db' job, delete the needs property
  #       9. Under the 'update-deployment-board-and-send-teams-notification' job, update the needs property to be: "needs: [deploy-az-db]"
  # repository_dispatch:
  #   types: [<deployable_name>_deploy] # TODO: Replace <deployable_name>.  This will be used in the 'Deploy Multiple Items' workflow to target this deployment workflow.

env:
  RELEASE_TAG: ${{ inputs.tag == 0 && github.ref_name || inputs.tag }} # This is the tag that we'll be deploying
  DB_SERVER_PORT: '1433' # TODO: Verify that this is the correct port
  MIGRATIONS_FOLDER: '' # TODO: Add the path to the migrations folder
  MIGRATIONS_HISTORY_TABLE: 'MigrationHistory' # TODO: Verify this table name

jobs:
  set-vars:
    needs: [examine-inputs]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners

    outputs:
      # To use these values: ${{ needs.set-vars.outputs.<OUTPUT_NAME> }}
      TARGET_RESOURCE_GROUP: ${{ steps.set-variables.outputs.TARGET_RESOURCE_GROUP }}
      PRIMARY_RESOURCE_GROUP: ${{ steps.set-variables.outputs.PRIMARY_RESOURCE_GROUP }}
      APP_INSIGHTS_NAME: ${{ steps.set-variables.outputs.APP_INSIGHTS_NAME }}
      APP_INSIGHTS_ANNOTATION: ${{ steps.set-variables.outputs.APP_INSIGHTS_ANNOTATION }}
      GITHUB_SECRETS_ENVIRONMENT: ${{ steps.set-variables.outputs.GITHUB_SECRETS_ENVIRONMENT }}

    steps:
      - name: Annotate Inputs
        run: |
          echo $'
          | Deploy Arguments          | Value                    |
          | ---                       |  ---                     |
          | Environment               | `${{ inputs.environment-or-target }}` |
          | Tag                       | `${{ env.RELEASE_TAG  }}`  |
          | Workflow Source           | `${{ github.ref_name }}` - SHA: `${{ github.sha }}` |' >> $GITHUB_STEP_SUMMARY

      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Verify Tag Exists
        uses: im-open/verify-git-ref@v1.2
        with:
          branch-tag-sha: ${{ env.RELEASE_TAG }}

      # For more information and best practices on the usage and options available
      # for this action go to: https://github.com/im-open/set-environment-variables-by-scope#usage-instructions
      - name: Set Variables
        id: set-variables
        uses: im-open/set-environment-variables-by-scope@v1.1
        with:
          scope: ${{ inputs.environment-or-target }}
          create-output-variables: true
        env:
          # Resource group you are targeting for deploy.  Also this variable is used to delete and re-create azure locks.
          # TODO: Add the NA27 (West Central US) Resource Group to the stage-secondary/prod-secondary to the variables.
          # TODO: Add the NA26 (West US2) Resource Groups to dev/qa/stage/demo/uat/prod to the variables
          TARGET_RESOURCE_GROUP@dev: ''
          TARGET_RESOURCE_GROUP@qa: ''
          TARGET_RESOURCE_GROUP@stage: ''
          TARGET_RESOURCE_GROUP@stage-secondary: ''
          TARGET_RESOURCE_GROUP@prod: ''
          TARGET_RESOURCE_GROUP@prod-secondary: ''

          # Resource group holding the state storage account and managed service identities
          # TODO: Add the Stage/Prod NA26 (West US2) Resource Groups below.
          PRIMARY_RESOURCE_GROUP@dev: ''
          PRIMARY_RESOURCE_GROUP@qa: ''
          PRIMARY_RESOURCE_GROUP@stage stage-secondary: ''
          PRIMARY_RESOURCE_GROUP@demo: ''
          PRIMARY_RESOURCE_GROUP@prod prod-secondary: ''

          # TODO: Add the NA26 (West Us2) AppInsights Instances to the variables
          # This variable is used to annotate app insights
          APP_INSIGHTS_NAME@dev: ''
          APP_INSIGHTS_NAME@qa: ''
          APP_INSIGHTS_NAME@stage stage-secondary: ''
          APP_INSIGHTS_NAME@demo: ''
          APP_INSIGHTS_NAME@uat: ''
          APP_INSIGHTS_NAME@prod prod-secondary: ''

          APP_INSIGHTS_ANNOTATION@dev qa stage prod: ''
          APP_INSIGHTS_ANNOTATION@stage-secondary prod-secondary: ''

          # Variables used for referencing secrets
          GITHUB_SECRETS_ENVIRONMENT@dev qa stage prod demo: '${{ inputs.environment-or-target }}'
          GITHUB_SECRETS_ENVIRONMENT@stage-secondary: 'stage'
          GITHUB_SECRETS_ENVIRONMENT@prod-secondary: 'prod'

  # Each env has their own stakeholder approval environment.  If no required reviewers are set for
  # that environment, the workflow will continue without requiring anyone to approve the deployment.
  stakeholder-approval:
    needs: [set-vars]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    environment: '${{ needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT }} Stakeholder Approval' # Use inputs context because env context is not available to environment:
    steps:
      - name: Approval Received
        run: echo "Stakeholder approval was received"

  # Each env has their own attestor approval environment (meant for QA Attestations).  If no required reviewers are set for
  # that environment, the workflow will continue without requiring anyone to approve the deployment.
  attestor-approval:
    needs: [set-vars]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    environment: '${{ needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT }} Attestor Approval' # Use inputs context because env context is not available to environment:
    steps:
      - run: |
          echo "Attestor approval was received or no required reviewers were set for this environment."

  # This job needs to run for all environments because deploy-az-db relies
  # on it but the steps inside this job will only run for the Prod env.
  validate-tag-for-prod-deploys:
    needs: [stakeholder-approval, attestor-approval]
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    steps:
      # In this job, always checkout the default branch (not the branch that was provided as an input).  Also use
      # fetch-depth: 0 to retrieve the history and tags so we can check if a tag is reachable from the default branch.
      - name: Checkout Repository
        if: needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT == 'prod'
        uses: actions/checkout@v3
        with:
          ref: 'main' # TODO: verify the name of your default branch
          fetch-depth: 0

      - uses: im-open/is-tag-reachable-from-default-branch@v1.1
        if: needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT == 'prod'
        with:
          tag: ${{ env.RELEASE_TAG }}

  # If you want to verify that the Jira ticket being deployed has the proper attestations, there is an action for that.
  # https://github.com/im-open/verify-fields-on-jira-task
  # Set up a new job, or add to an existing one that makes sense, and add a step with that action.
  # Details on how to use the action can be found in the action's README.

  deploy-az-db:
    needs: [set-vars, validate-tag-for-prod-deploys]
    runs-on: [self-hosted, ubuntu-20.04]
    environment: ${{ needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT }}
    outputs:
      DB_NAME: ${{ steps.db-vars.outputs.DB_NAME }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          ref: ${{ env.RELEASE_TAG }}

      # TODO: If your database uses Azure Active Directory Authentication then this step can be removed
      - name: AZ Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Flyway
        uses: im-open/setup-flyway@v1.1
        with:
          version: 7.9.2

      # TODO: Use this for any variables that change per environment
      # For more information and best practices on the usage and options available
      # for this action go to: https://github.com/im-open/set-environment-variables-by-scope#usage-instructions
      - name: Set Database Vars
        id: db-vars
        uses: im-open/set-environment-variables-by-scope@v1.1
        with:
          scope: ${{ inputs.environment-or-target }}
          create-output-variables: true
          input-file: '' # TODO: if you have an input file with your variable substitutions, add them here
        env:
          DB_NAME@dev qa stage stage-secondary prod prod-secondary: ''

          DB_SERVER_NAME@dev: ''
          DB_SERVER_NAME@qa: ''
          DB_SERVER_NAME@stage: ''
          DB_SERVER_NAME@prod: ''
          DB_SERVER_NAME@stage-secondary: ''
          DB_SERVER_NAME@prod-secondary: ''

          AZURE_KEY_VAULT@dev: ''
          AZURE_KEY_VAULT@qa: ''
          AZURE_KEY_VAULT@stage stage-secondary: ''
          AZURE_KEY_VAULT@prod prod-secondary: ''

      # Get the Azure SQL Creds from Key Vault
      # TODO: If your database uses Azure Active Directory Authentication then this step can be removed
      - name: Get Azure SQL Credentials
        run: |
          sqlUser=$(az keyvault secret show --vault-name "${{ env.AZURE_KEY_VAULT }}" --name "sqluser" --query value)
          sqlPassword=$(az keyvault secret show --vault-name "${{ env.AZURE_KEY_VAULT }}" --name "sqlpassword" --query value)
          echo "::add-mask::$sqlPassword"
          # trim quotes added by az keyvault command
          sqlUser=$(sed -e 's/^"//' -e 's/"$//' <<<"$sqlUser")
          sqlPassword=$(sed -e 's/^"//' -e 's/"$//' <<<"$sqlPassword")
          echo "SQL_USER=$sqlUser" >> $GITHUB_ENV
          echo "SQL_PASSWORD=$sqlPassword" >> $GITHUB_ENV

      # TODO: If your database uses Azure Active Directory Authentication then you can login with a Service Principal
      #       instead of using the username and password of an account stored in Key Vault.
      #       See https://github.com/im-open/run-flyway-command for details.
      - name: Deploy migrations
        uses: im-open/run-flyway-command@v1.4
        with:
          db-server-name: '${{ steps.db-vars.outputs.DB_SERVER_NAME }}'
          db-server-port: '${{ env.DB_SERVER_PORT }}'
          db-name: '${{ steps.db-vars.outputs.DB_NAME }}'
          migration-files-path: '${{ env.MIGRATIONS_FOLDER }}'
          flyway-command: 'migrate'
          migration-history-table: '${{ env.MIGRATIONS_HISTORY_TABLE }}'
          baseline-version: '0'
          managed-schemas: 'dbo' # TODO: Update this csv with the schemas that flyway manages (e.g. 'dbo,CustomSchema,OtherSchema')
          enable-out-of-order: 'false'
          use-integrated-security: 'false'
          username: '${{ env.SQL_USER }}'
          password: '${{ env.SQL_PASSWORD }}'

      - name: Annotate App Insights
        uses: im-open/create-app-insights-annotation@v1.0
        with:
          subscriptionId: ${{ secrets.ARM_SUBSCRIPTION_ID }} # This is an env-level secret
          resourceGroupName: ${{ needs.set-vars.outputs.PRIMARY_RESOURCE_GROUP }}
          appInsightsResourceName: '${{ needs.set-vars.outputs.APP_INSIGHTS_NAME }}'
          releaseName: '${{ needs.set-vars.outputs.APP_INSIGHTS_ANNOTATION }}'
          category: 'Deployment'
          customMetadata: 'ProjectName=${{ needs.set-vars.outputs.APP_INSIGHTS_ANNOTATION }},DeployedBy=${{ github.actor }},RunID=${{ github.run_id }}'

      - name: Azure logout
        if: always() && steps.login.outcome == 'success'
        run: |
          az logout
          az cache purge
          az account clear

  update-deployment-board-and-send-teams-notification:
    runs-on: ubuntu-latest # Force this to run on github-hosted runner by using a tag that does not exist on self-hosted runners
    needs: [set-vars, deploy-az-db]
    if: always()
    uses: im-practices/.github/.github/workflows/im-reusable-finish-deployment-workflow.yml@v2
    with:
      # Required Inputs
      deployment-environment: ${{ inputs.environment-or-target }}                      # The environment/target that was deployed to (dev, qa, stage, stage-secondary, uat, demo, prod, prod-secondary)
      gh-secrets-environment: ${{ needs.set-vars.outputs.GITHUB_SECRETS_ENVIRONMENT }} # The GitHub environment that secrets are pulled from
      release-tag: ${{ inputs.tag == 0 && github.ref_name || inputs.tag }}
      title-of-teams-post: 'Deploy ${{ needs.deploy-az-db.outputs.DB_NAME }} ${{ inputs.tag == 0 && github.ref_name || inputs.tag }} to ${{ inputs.environment-or-target }}' # TODO:  Verify title to ensure it is descriptive/readable.
      
      # Optional Inputs with their default values.  These items can be removed if the default value does not need to be adjusted.
      # post-status-in-deployment-notifications-channel: true # TODO:  Include this arg and set to false if you do not want a status post in the Deployment Notifications channel for prod deploys
      # timezone: 'america/denver'                            # TODO:  Include this argument and update if your timezone is not america/denver
      # deployment-board-number: 1                            # TODO:  Include this argument and update if your deployment board is not 1
      # deployable-type: ''                                   # TODO:  If there are multiple deployables in the repository, add a string type like MFE/DB/API for the deployment board
      # TODO:  These are the custom facts that will be included the different Teams posts by default.  If adjusting the facts that are supplied, they must be a valid JSON array.
      # custom-facts-for-team-channel: |
      #   [
      #     { "name": "Workflow", "value": "${{ github.workflow }}" },
      #     { "name": "Run", "value": "${{ github.run_id }}" },
      #     { "name": "Actor", "value": "${{ github.actor }}" },
      #     { "name": "Version", "value": "${{ inputs.tag == 0 && github.ref_name || inputs.tag}}" }
      #   ]
      # custom-facts-for-deployment-notifications-channel: |
      #   [
      #     { "name": "Actor", "value": "${{ github.actor }}" },
      #     { "name": "Version", "value": "${{ inputs.tag == 0 && github.ref_name || inputs.tag }}" }
      #   ]
    secrets:
      MS_TEAMS_URI: ${{ secrets.MS_TEAMS_URI }}
      DEPLOY_NOTIFICATIONS_CHANNEL: ${{ secrets.DEPLOY_NOTIFICATIONS_CHANNEL }}    
